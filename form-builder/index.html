<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Form Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }

        /* === Form Preview Styles === */
        .preview-page {
            width: 8.5in;
            min-height: 11in;
            background: #fff;
            padding: 0.5in 0.6in 0.4in;
            box-shadow: 0 4px 18px rgba(0,0,0,0.12);
            position: relative;
        }

        /* Page break indicator */
        .page-break-indicator {
            position: absolute;
            left: 0;
            right: 0;
            height: 0;
            border-top: 2px dashed #BA0C2F;
            pointer-events: none;
        }
        .page-break-indicator::before {
            content: 'Page Break';
            position: absolute;
            right: -70px;
            top: -10px;
            font-size: 10px;
            color: #BA0C2F;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            white-space: nowrap;
        }
        .page-break-indicator::after {
            content: attr(data-page);
            position: absolute;
            left: -55px;
            top: -10px;
            font-size: 10px;
            color: #666;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Letterhead - fixed at top */
        .preview-letterhead {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding-bottom: 16px;
            margin-bottom: 20px;
            border-bottom: 1px solid #ccc;
        }
        .preview-letterhead-logo img {
            height: 60px;
            width: auto;
        }
        .preview-letterhead-right {
            text-align: right;
            font-family: Georgia, serif;
        }
        .preview-letterhead-title {
            font-size: 14px;
            font-weight: 400;
            color: #000;
            text-decoration: underline;
            margin-bottom: 6px;
        }
        .preview-letterhead-address {
            font-size: 11px;
            color: #333;
            line-height: 1.4;
        }

        .preview-section {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #e2e2e2;
            background: #fafafa;
        }
        .preview-section-header {
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #BA0C2F;
            margin-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }

        .preview-field-label {
            font-size: 13px;
            font-weight: 600;
            color: #4a4a4a;
            margin-bottom: 3px;
        }
        .preview-field-line {
            border: 1px solid #cfcfcf;
            border-radius: 3px;
            height: 24px;
            margin-bottom: 6px;
            background: #fff;
        }
        .preview-field-multiline {
            border: 1px solid #cfcfcf;
            border-radius: 3px;
            height: 48px;
            margin-bottom: 6px;
            background: #fff;
        }

        .preview-notice {
            background: #fff8f5;
            border-left: 4px solid #BA0C2F;
            padding: 10px 14px;
            font-size: 12px;
            line-height: 1.5;
        }

        .preview-row { display: flex; gap: 12px; }
        .preview-row > div { flex: 1; }
        .preview-row .col-city { flex: 2; }
        .preview-row .col-state { flex: 0.8; }
        .preview-row .col-postal { flex: 1.2; }

        .preview-signature-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .preview-signature-label {
            font-size: 13px;
            font-weight: 600;
            color: #4a4a4a;
            width: 140px;
            flex-shrink: 0;
            overflow-wrap: break-word;
            line-height: 1.3;
        }
        .preview-signature-line {
            flex: 1;
            border-bottom: 1px solid #999;
            height: 20px;
        }

        .preview-office-use {
            background: #fff;
            border: 2px dashed #999;
            border-radius: 6px;
            padding: 8px 12px;
        }
        .preview-office-use .preview-section-header {
            color: #4a4a4a;
            font-style: italic;
        }

        .preview-checkbox-row {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 11px;
            margin-top: 4px;
        }
        .preview-checkbox {
            width: 14px;
            height: 14px;
            border: 1.5px solid #555;
            border-radius: 2px;
            display: inline-block;
            margin-right: 5px;
            vertical-align: middle;
        }

        /* Block selection & consistent spacing */
        .block-item { position: relative; cursor: pointer; margin-bottom: 10px; }
        .block-item:last-child { margin-bottom: 0; }
        .block-item:hover { outline: 1px dashed #ccc; outline-offset: 2px; }
        .block-item.selected { outline: 2px solid #BA0C2F; outline-offset: 2px; }

        /* Letterhead selection */
        .letterhead-wrapper { cursor: pointer; }
        .letterhead-wrapper:hover { outline: 1px dashed #ccc; outline-offset: 2px; }
        .letterhead-wrapper.selected { outline: 2px solid #BA0C2F; outline-offset: 2px; }

        /* Block buttons */
        .block-btn { transition: all 0.1s ease; }
        .block-btn:hover { background: #f0f0f0; }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <!-- Login Screen -->
    <div id="loginScreen" class="fixed inset-0 z-[100] flex items-center justify-center" style="background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);">
        <div class="bg-white rounded-xl shadow-2xl p-8 w-full max-w-sm text-center">
            <div class="mb-6">
                <div class="flex items-center justify-center gap-3 mb-2">
                    <i data-lucide="file-stack" class="w-10 h-10 text-red-700"></i>
                    <span class="text-2xl font-bold text-gray-800">REGI</span>
                </div>
                <h1 class="text-xl font-semibold text-gray-700">Form Builder</h1>
                <p class="text-sm text-gray-400 mt-2">Enter password to continue</p>
            </div>
            <form onsubmit="return attemptLogin(event)">
                <input type="password" id="loginPassword" placeholder="Password" autofocus
                    class="w-full px-4 py-3 border border-gray-300 rounded-lg text-center text-lg focus:outline-none focus:border-red-400 focus:ring-2 focus:ring-red-100 mb-4">
                <p id="loginError" class="text-red-500 text-sm mb-3 hidden">Incorrect password</p>
                <button type="submit" class="w-full bg-red-700 text-white py-3 rounded-lg font-medium hover:bg-red-800 transition-colors">
                    Sign In
                </button>
            </form>
            <p class="text-xs text-gray-400 mt-6">Office of the Registrar</p>
        </div>
    </div>

    <!-- Main App Container (hidden until login) -->
    <div id="mainApp" class="hidden">

    <!-- Toolbar -->
    <header class="bg-white border-b px-4 py-2.5 flex items-center justify-between sticky top-0 z-50" style="height:49px;box-sizing:border-box;">
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
                <i data-lucide="file-stack" class="w-5 h-5 text-red-700"></i>
                <span class="font-semibold text-gray-800">REGI Form Builder</span>
            </div>
            <input type="text" id="formTitle" value="Untitled Form"
                   class="text-sm border border-gray-300 rounded px-2 py-1 w-56 focus:outline-none focus:border-gray-500">
        </div>
        <div class="flex items-center gap-2">
            <button onclick="newForm()" class="px-3 py-1.5 text-sm border border-gray-300 rounded hover:bg-gray-50">New</button>
            <button onclick="openLibrary()" class="px-3 py-1.5 text-sm border border-gray-300 rounded hover:bg-gray-50 flex items-center gap-1">
                <i data-lucide="folder-open" class="w-4 h-4"></i> Library
            </button>
            <button onclick="saveToServer()" class="px-3 py-1.5 text-sm border border-gray-300 rounded hover:bg-gray-50">Save</button>
            <button onclick="exportPDF()" class="px-4 py-1.5 text-sm bg-gray-800 text-white rounded hover:bg-gray-700">Export PDF</button>
        </div>
    </header>

    <div class="flex h-[calc(100vh-49px)]">

        <!-- Left: Block Library -->
        <aside class="w-56 bg-white border-r p-3 overflow-y-auto flex-shrink-0 flex flex-col">
            <div class="flex-1">
                <!-- Reusable Blocks -->
                <p class="text-xs font-medium text-gray-400 uppercase tracking-wide mb-2">Reusable Blocks</p>
                <div class="space-y-1 mb-4">
                    <button onclick="addBlock('student-info')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="user" class="w-4 h-4 text-gray-400"></i>
                        Student Information
                    </button>
                    <button onclick="addBlock('address')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="map-pin" class="w-4 h-4 text-gray-400"></i>
                        Address Block
                    </button>
                    <button onclick="addBlock('signature')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="pen-tool" class="w-4 h-4 text-gray-400"></i>
                        Signature Line
                    </button>
                    <button onclick="addBlock('office-use')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="lock" class="w-4 h-4 text-gray-400"></i>
                        Office Use Only
                    </button>
                    <button onclick="addBlock('footer')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="file-text" class="w-4 h-4 text-gray-400"></i>
                        Revision Date
                    </button>
                    <button onclick="addBlock('course-info')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="book-open" class="w-4 h-4 text-gray-400"></i>
                        Course Information
                    </button>
                </div>

                <!-- Custom Blocks -->
                <p class="text-xs font-medium text-gray-400 uppercase tracking-wide mb-2">Custom Blocks</p>
                <div class="space-y-1">
                    <button onclick="addBlock('section-title')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="minus" class="w-4 h-4 text-gray-400"></i>
                        Section Title Bar
                    </button>
                    <button onclick="addBlock('info-paragraph')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="file-text" class="w-4 h-4 text-gray-400"></i>
                        Information Paragraph
                    </button>
                    <button onclick="addBlock('notice')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="alert-circle" class="w-4 h-4 text-gray-400"></i>
                        Notice Box
                    </button>
                    <div class="text-field-group">
                        <button onclick="toggleTextFieldMenu()" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                            <i data-lucide="text-cursor-input" class="w-4 h-4 text-gray-400"></i>
                            Text Input Field
                            <i data-lucide="chevron-right" class="w-3 h-3 text-gray-400 ml-auto transition-transform" id="textFieldChevron"></i>
                        </button>
                        <div id="textFieldMenu" class="hidden pl-6 py-1 space-y-1">
                            <button onclick="addTextFields(1)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">1 Column</button>
                            <button onclick="addTextFields(2)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">2 Columns</button>
                            <button onclick="addTextFields(3)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">3 Columns</button>
                            <button onclick="addTextFields(4)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">4 Columns</button>
                        </div>
                    </div>
                    <button onclick="addBlock('textarea')" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                        <i data-lucide="align-left" class="w-4 h-4 text-gray-400"></i>
                        Text Input Area
                    </button>
                    <div class="checkbox-group">
                        <button onclick="toggleCheckboxMenu()" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                            <i data-lucide="check-square" class="w-4 h-4 text-gray-400"></i>
                            Checkbox Group
                            <i data-lucide="chevron-right" class="w-3 h-3 text-gray-400 ml-auto transition-transform" id="checkboxChevron"></i>
                        </button>
                        <div id="checkboxMenu" class="hidden pl-6 py-1 space-y-1">
                            <button onclick="addCheckboxGroup('horizontal')" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">Horizontal</button>
                            <button onclick="addCheckboxGroup('vertical')" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">Vertical (stacked)</button>
                        </div>
                    </div>
                    <div class="dropdown-group">
                        <button onclick="toggleDropdownMenu()" class="block-btn w-full text-left px-2.5 py-2 rounded text-sm flex items-center gap-2 border border-transparent hover:border-gray-200">
                            <i data-lucide="chevron-down-square" class="w-4 h-4 text-gray-400"></i>
                            Dropdown Field
                            <i data-lucide="chevron-right" class="w-3 h-3 text-gray-400 ml-auto transition-transform" id="dropdownChevron"></i>
                        </button>
                        <div id="dropdownMenu" class="hidden pl-6 py-1 space-y-1">
                            <button onclick="addDropdownFields(1)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">1 Dropdown</button>
                            <button onclick="addDropdownFields(2)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">2 Dropdowns (row)</button>
                            <button onclick="addDropdownFields(3)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">3 Dropdowns (row)</button>
                            <button onclick="addDropdownFields(4)" class="block-btn w-full text-left px-2 py-1.5 rounded text-xs text-gray-600 hover:bg-gray-100">4 Dropdowns (row)</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Logo at bottom -->
            <div class="pt-4 mt-4 border-t">
                <img src="../images/OfficeRegistrar_logo_Horizontal_FC.svg" alt="Office of the Registrar" class="w-full opacity-60">
            </div>
        </aside>

        <!-- Center: Preview -->
        <main class="flex-1 overflow-auto bg-gray-200 p-6">
            <div class="flex justify-center">
                <div id="preview" class="preview-page">
                </div>
            </div>
        </main>

        <!-- Right: Properties -->
        <aside class="w-64 bg-white border-l p-3 overflow-y-auto flex-shrink-0">
            <p class="text-xs font-medium text-gray-400 uppercase tracking-wide mb-2">Properties</p>
            <div id="props">
                <p class="text-sm text-gray-400 italic">Select a block to edit</p>
            </div>
        </aside>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleLoad(event)">

    <!-- Generic Modal -->
    <div id="appModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-[60] flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
            <div class="px-4 py-3 border-b">
                <h2 id="modalTitle" class="text-lg font-semibold text-gray-800">Message</h2>
            </div>
            <div class="p-4">
                <p id="modalMessage" class="text-gray-600"></p>
            </div>
            <div id="modalButtons" class="px-4 py-3 border-t bg-gray-50 flex justify-end gap-2">
            </div>
        </div>
    </div>

    <!-- Library Modal -->
    <div id="libraryModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex items-center justify-between px-4 py-3 border-b">
                <h2 class="text-lg font-semibold text-gray-800">Form Library</h2>
                <button onclick="closeLibrary()" class="text-gray-400 hover:text-gray-600">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <!-- Folder navigation breadcrumb -->
            <div class="px-4 py-2 bg-gray-50 border-b flex items-center gap-2">
                <div id="folderBreadcrumb" class="flex items-center gap-1 text-sm flex-1">
                    <button onclick="navigateToFolder(null)" class="text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1">
                        <i data-lucide="home" class="w-4 h-4"></i> All Forms
                    </button>
                </div>
                <button onclick="createNewFolder()" class="px-2 py-1 text-xs border border-gray-300 rounded hover:bg-white flex items-center gap-1" title="Create new folder">
                    <i data-lucide="folder-plus" class="w-4 h-4"></i> New Folder
                </button>
            </div>
            <div class="p-4 overflow-y-auto flex-1">
                <div id="libraryList" class="space-y-2">
                    <p class="text-gray-400 text-sm text-center py-8">Loading...</p>
                </div>
            </div>
            <div class="px-4 py-3 border-t bg-gray-50 flex justify-between items-center">
                <button onclick="loadFromFile()" class="px-3 py-1.5 text-sm border border-gray-300 rounded hover:bg-white flex items-center gap-1">
                    <i data-lucide="upload" class="w-4 h-4"></i> Import from File
                </button>
                <button onclick="closeLibrary()" class="px-3 py-1.5 text-sm border border-gray-300 rounded hover:bg-white">Close</button>
            </div>
        </div>
    </div>

    </div><!-- End mainApp -->

    <script>
        // Login functionality
        const LOGIN_KEY = 'regi_form_builder_auth';
        const LOGIN_EXPIRY_DAYS = 7;
        const CORRECT_PASSWORD = 'a11yforms';

        function checkLogin() {
            const stored = localStorage.getItem(LOGIN_KEY);
            if (stored) {
                const { expiry } = JSON.parse(stored);
                if (new Date().getTime() < expiry) {
                    showApp();
                    return true;
                }
                localStorage.removeItem(LOGIN_KEY);
            }
            return false;
        }

        function attemptLogin(event) {
            event.preventDefault();
            const password = document.getElementById('loginPassword').value;
            if (password === CORRECT_PASSWORD) {
                const expiry = new Date().getTime() + (LOGIN_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
                localStorage.setItem(LOGIN_KEY, JSON.stringify({ expiry }));
                showApp();
            } else {
                document.getElementById('loginError').classList.remove('hidden');
                document.getElementById('loginPassword').value = '';
                document.getElementById('loginPassword').focus();
            }
            return false;
        }

        function showApp() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            lucide.createIcons();
        }

        // Check login on page load
        if (!checkLogin()) {
            lucide.createIcons(); // For login screen icons
        }

        lucide.createIcons();

        // Letterhead is always present (title is editable)
        let letterheadTitle = 'Title';

        let blocks = [];
        let selectedId = null; // 'letterhead' or block id
        let idCounter = 0;
        let currentTemplateId = null; // Track current server template ID
        let currentFormFolder = null; // Track folder of currently loaded form
        let currentLibraryFolder = null; // Track current folder in library navigation
        let modalResolve = null; // For modal promise resolution

        // Custom modal functions to replace browser popups
        function showModal(title, message, buttons = [{ text: 'OK', primary: true }]) {
            return new Promise((resolve) => {
                modalResolve = resolve;
                document.getElementById('modalTitle').textContent = title;
                document.getElementById('modalMessage').innerHTML = message;
                const btnContainer = document.getElementById('modalButtons');
                btnContainer.innerHTML = buttons.map((btn, i) => `
                    <button onclick="closeModal(${btn.value !== undefined ? btn.value : (btn.primary ? 'true' : 'false')})"
                        class="px-4 py-2 text-sm rounded ${btn.primary ? 'bg-gray-800 text-white hover:bg-gray-700' : 'border border-gray-300 hover:bg-gray-50'}">
                        ${btn.text}
                    </button>
                `).join('');
                document.getElementById('appModal').classList.remove('hidden');
            });
        }

        function closeModal(value) {
            document.getElementById('appModal').classList.add('hidden');
            if (modalResolve) {
                modalResolve(value);
                modalResolve = null;
            }
        }

        async function showAlert(message, title = 'Notice') {
            await showModal(title, message, [{ text: 'OK', primary: true }]);
        }

        async function showConfirm(message, title = 'Confirm') {
            return await showModal(title, message, [
                { text: 'Cancel', primary: false, value: false },
                { text: 'Continue', primary: true, value: true }
            ]);
        }

        async function showSuccess(message) {
            await showModal('Success', message, [{ text: 'OK', primary: true }]);
        }

        // RODS API Configuration
        const RODS_API_BASE = 'https://apps8.reg.uga.edu/rods_api';
        const RODS_TABLE = 'pdf_forms';
        const RODS_API_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoicm9kc19hcGkiLCJleHAiOjE4OTM0NTYwMDB9._3h0fg8OwgAMDoW-dcYY8H9dPgLLqYWSaiPgL0pLXfQ';

        // Helper for API headers
        function getApiHeaders(forWrite = false) {
            const headers = {
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache'
            };
            if (forWrite) {
                headers['Prefer'] = 'return=representation';
            }
            if (RODS_API_TOKEN) {
                headers['Authorization'] = `Bearer ${RODS_API_TOKEN}`;
            }
            return headers;
        }

        const templates = {
            'section': { type: 'section', title: 'Section Title' },
            'section-title': { type: 'section-title', title: 'SECTION TITLE' },
            'notice': { type: 'notice', title: 'Notice:', text: 'Enter notice text here.' },
            'text-field': { type: 'text-field', fields: [{ label: 'Field Label', fieldName: 'field_1' }], required: false },
            'textarea': { type: 'textarea', label: 'Field Label', fieldName: 'field', rows: 2, required: false },
            'checkbox': { type: 'checkbox', label: 'Options', layout: 'vertical', options: [{ text: 'Option 1', bold: false, hasField: false, fieldRows: 1 }, { text: 'Option 2', bold: false, hasField: false, fieldRows: 1 }], fieldName: 'checkbox', required: false },
            'dropdown': { type: 'dropdown', dropdowns: [{ label: 'Dropdown', fieldName: 'dropdown_1', options: ['Option 1', 'Option 2', 'Option 3'] }], required: false },
            'address': { type: 'address', title: 'Address', fieldPrefix: 'addr', includePhone: false, includeTypeSelector: false },
            'student-info': { type: 'student-info', title: 'Student Information', fieldPrefix: 'student' },
            'course-info': { type: 'course-info', title: 'Course Information', fieldPrefix: 'course' },
            'signature': { type: 'signature', label: 'Signature', fieldName: 'sig', includeDate: true, includePhotoId: false, required: true },
            'office-use': { type: 'office-use', title: 'Office Use Only', includeApprovalCheckboxes: false, lines: ['System Updated By', 'Date'] },
            'footer': { type: 'footer', revisedMonth: 'January', revisedYear: '2026' },
            'info-paragraph': { type: 'info-paragraph', title: 'Information', text: 'Enter paragraph text here. Use **bold** for emphasis.' }
        };

        function addBlock(type) {
            const block = JSON.parse(JSON.stringify(templates[type]));
            block.id = ++idCounter;
            // Auto-generate unique field names based on block ID to prevent duplicates
            if (block.fieldName) {
                block.fieldName = block.fieldName + '_' + block.id;
            }
            if (block.fieldPrefix) {
                block.fieldPrefix = block.fieldPrefix + '_' + block.id;
            }
            if (block.fields) {
                block.fields.forEach((f, i) => {
                    f.fieldName = f.fieldName + '_' + block.id;
                });
            }
            blocks.push(block);
            selectedId = block.id;
            render();
        }

        function toggleTextFieldMenu() {
            const menu = document.getElementById('textFieldMenu');
            const chevron = document.getElementById('textFieldChevron');
            menu.classList.toggle('hidden');
            chevron.style.transform = menu.classList.contains('hidden') ? '' : 'rotate(90deg)';
        }

        function addTextFields(columns) {
            const row = [];
            for (let i = 1; i <= columns; i++) {
                row.push({ label: 'Field ' + i, fieldName: 'field_' + i });
            }
            const block = {
                type: 'text-field',
                id: ++idCounter,
                columns: columns,
                rows: [row],
                required: false,
                showSection: false,
                sectionTitle: 'Section Title'
            };
            blocks.push(block);
            selectedId = block.id;
            render();
        }

        function addTextFieldRow() {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || b.type !== 'text-field') return;
            migrateTextFieldBlock(b);
            const newRow = [];
            const rowNum = b.rows.length + 1;
            for (let i = 1; i <= b.columns; i++) {
                newRow.push({ label: 'Field ' + ((rowNum - 1) * b.columns + i), fieldName: 'field_' + rowNum + '_' + i });
            }
            b.rows.push(newRow);
            render();
        }

        function removeTextFieldRow(rowIndex) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || b.type !== 'text-field') return;
            migrateTextFieldBlock(b);
            if (b.rows.length <= 1) return;
            b.rows.splice(rowIndex, 1);
            render();
        }

        function migrateTextFieldBlock(b) {
            // Migrate old format (fields array) to new format (rows array)
            if (b.type === 'text-field' && !b.rows && b.fields) {
                b.rows = [b.fields];
                b.columns = b.fields.length;
                b.showSection = b.showSection || false;
                b.sectionTitle = b.sectionTitle || 'Section Title';
                delete b.fields;
            }
        }

        function updateTextFieldCell(rowIndex, colIndex, prop, value) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b) return;
            migrateTextFieldBlock(b);
            if (!b.rows || !b.rows[rowIndex] || !b.rows[rowIndex][colIndex]) return;
            b.rows[rowIndex][colIndex][prop] = value;
            renderPreview();
        }

        function toggleCheckboxMenu() {
            const menu = document.getElementById('checkboxMenu');
            const chevron = document.getElementById('checkboxChevron');
            menu.classList.toggle('hidden');
            chevron.style.transform = menu.classList.contains('hidden') ? '' : 'rotate(90deg)';
        }

        function addCheckboxGroup(layout) {
            const block = {
                type: 'checkbox',
                id: ++idCounter,
                label: 'Options',
                layout: layout,
                options: [
                    { text: 'Option 1', bold: false, italic: false, underline: false },
                    { text: 'Option 2', bold: false, italic: false, underline: false }
                ],
                fieldName: 'checkbox',
                required: false
            };
            blocks.push(block);
            selectedId = block.id;
            render();
        }

        function toggleDropdownMenu() {
            const menu = document.getElementById('dropdownMenu');
            const chevron = document.getElementById('dropdownChevron');
            menu.classList.toggle('hidden');
            chevron.style.transform = menu.classList.contains('hidden') ? '' : 'rotate(90deg)';
        }

        function addDropdownFields(count) {
            const dropdowns = [];
            for (let i = 1; i <= count; i++) {
                dropdowns.push({ label: 'Dropdown ' + i, fieldName: 'dropdown_' + i, options: ['Option 1', 'Option 2', 'Option 3'] });
            }
            const block = {
                type: 'dropdown',
                id: ++idCounter,
                dropdowns: dropdowns,
                showSection: false,
                sectionTitle: 'Section Title'
            };
            blocks.push(block);
            selectedId = block.id;
            render();
        }

        function renderPreview() {
            const preview = document.getElementById('preview');
            preview.innerHTML = '';

            // Always render letterhead first
            const letterhead = document.createElement('div');
            letterhead.className = `letterhead-wrapper ${selectedId === 'letterhead' ? 'selected' : ''}`;
            letterhead.onclick = (e) => { e.stopPropagation(); selectedId = 'letterhead'; render(); };
            letterhead.innerHTML = `
                <div class="preview-letterhead">
                    <div class="preview-letterhead-logo">
                        <img src="../images/OfficeRegistrar_logo_Horizontal_FC.svg" alt="Office of the Registrar - University of Georgia">
                    </div>
                    <div class="preview-letterhead-right">
                        <div class="preview-letterhead-title">${letterheadTitle}</div>
                        <div class="preview-letterhead-address">
                            University of Georgia<br>
                            Office of the Registrar<br>
                            Holmes-Hunter Academic Building<br>
                            Athens, Georgia 30602
                        </div>
                    </div>
                </div>
            `;
            preview.appendChild(letterhead);

            // Render blocks
            if (blocks.length === 0) {
                const empty = document.createElement('p');
                empty.className = 'text-gray-400 text-center py-10 text-sm';
                empty.textContent = 'Click a block to add content';
                preview.appendChild(empty);
            } else {
                blocks.forEach(b => {
                    const el = document.createElement('div');
                    el.className = `block-item ${selectedId === b.id ? 'selected' : ''}`;
                    el.onclick = (e) => { e.stopPropagation(); selectedId = b.id; render(); };
                    el.innerHTML = renderBlock(b);
                    preview.appendChild(el);
                });
            }

            lucide.createIcons();

            // Add page break indicators
            setTimeout(() => addPageBreakIndicators(), 50);
        }

        function render() {
            renderPreview();
            renderProps();
        }

        function addPageBreakIndicators() {
            const preview = document.getElementById('preview');
            // Remove existing indicators
            preview.querySelectorAll('.page-break-indicator').forEach(el => el.remove());

            // Page is 11 inches, at 96dpi = 1056px
            // But the preview has CSS padding built in, so we measure actual usable space
            // Adding extra buffer since PDF has more room than preview suggests
            const pageHeightPx = 11 * 96 + 40; // 11 inches + buffer for more accuracy
            const usableHeight = 10.1 * 96 + 40; // Usable content area + buffer

            const contentHeight = preview.scrollHeight;

            // Add indicators for each page break
            let pageNum = 1;
            let breakPoint = pageHeightPx;
            while (breakPoint < contentHeight) {
                const indicator = document.createElement('div');
                indicator.className = 'page-break-indicator';
                indicator.style.top = breakPoint + 'px';
                indicator.dataset.page = 'Page ' + pageNum + ' ends';
                preview.appendChild(indicator);
                pageNum++;
                breakPoint += usableHeight;
            }
        }

        function renderBlock(b) {
            switch(b.type) {
                case 'section':
                    return `<div class="preview-section">
                        <div class="preview-section-header">${b.title}</div>
                    </div>`;

                case 'section-title':
                    return `<div style="background:#666;padding:6px 12px;">
                        <div style="font-size:12px;font-weight:500;text-transform:uppercase;letter-spacing:0.1em;color:#fff;">${b.title}</div>
                    </div>`;

                case 'notice':
                    // Parse **bold** markdown using shared function
                    const noticeTextFormatted = markdownToHtml(b.text || '');
                    return `<div class="preview-notice"><strong>${b.title}</strong> ${noticeTextFormatted}</div>`;

                case 'text-field':
                    // Handle both old format (fields array) and new format (rows array)
                    const tfRows = b.rows || [b.fields || [{ label: b.label || 'Field' }]];
                    const tfCols = b.columns || (b.fields ? b.fields.length : 1);
                    const reqStar = b.required ? ' <span style="color:#BA0C2F;">*</span>' : '';

                    let tfRowsHtml = tfRows.map(row => {
                        if (tfCols === 1) {
                            const f = row[0] || { label: 'Field' };
                            return `<div style="margin-bottom:8px;">
                                <div class="preview-field-label">${f.label}${reqStar}</div>
                                <div class="preview-field-line"></div>
                            </div>`;
                        } else {
                            const cols = row.map(f => `<div><div class="preview-field-label">${f.label}${reqStar}</div><div class="preview-field-line"></div></div>`).join('');
                            return `<div style="display:grid;grid-template-columns:repeat(${tfCols}, 1fr);gap:10px;margin-bottom:8px;">${cols}</div>`;
                        }
                    }).join('');

                    if (b.showSection) {
                        const titleHtml = b.hideTitle ? '' : `<div class="preview-section-header">${b.sectionTitle || 'Section Title'}</div>`;
                        return `<div class="preview-section">
                            ${titleHtml}
                            ${tfRowsHtml}
                        </div>`;
                    } else {
                        return `<div>${tfRowsHtml}</div>`;
                    }

                case 'textarea':
                    return `<div>
                        <div class="preview-field-label">${b.label}${b.required ? ' <span style="color:#BA0C2F;">*</span>' : ''}</div>
                        <div class="preview-field-multiline" style="height:${b.rows * 24}px"></div>
                    </div>`;

                case 'checkbox':
                    const cbOpts = (b.options || []).map(o => {
                        // Handle both old string format and new object format
                        const text = typeof o === 'string' ? o : o.text;
                        const style = typeof o === 'object' ? o : {};
                        let styled = text;
                        if (style.bold) {
                            styled = `<strong>${styled}</strong>`;
                        } else {
                            // Parse **bold** markdown per-word
                            styled = styled.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                        }
                        // Add fillable field if enabled (rows-based height)
                        const rows = style.fieldRows || 1;
                        const fieldHeight = rows === 1 ? '18px' : (rows * 20) + 'px';
                        const fieldHtml = style.hasField ? `<div class="preview-field-${rows === 1 ? 'line' : 'multiline'}" style="flex:1;min-width:150px;margin:0;${rows > 1 ? 'height:' + fieldHeight : ''}"></div>` : '';
                        // In horizontal layout, don't force full width; in vertical, allow full width
                        const optionWidth = b.layout === 'vertical' ? 'width:100%;' : '';
                        return `<div style="display:flex;align-items:flex-start;gap:6px;${optionWidth}min-width:0;${b.layout === 'vertical' ? 'margin-bottom:8px;' : ''}"><span class="preview-checkbox" style="flex-shrink:0;margin-top:2px;"></span><span style="font-size:11px;color:#4a4a4a;word-wrap:break-word;overflow-wrap:break-word;min-width:0;${b.layout === 'vertical' ? 'flex:1;' : ''}">${styled}</span>${fieldHtml}</div>`;
                    }).join('');
                    const cbLayout = b.layout === 'vertical' ? 'flex-direction:column;align-items:stretch;' : 'flex-direction:row;flex-wrap:wrap;gap:16px;';
                    const cbRequired = b.required ? '<span style="color:#BA0C2F;"> *</span>' : '';
                    return `<div>
                        <div style="border:1px solid #ccc;border-radius:4px;padding:16px 12px 10px 12px;position:relative;margin-top:8px;">
                            <div style="position:absolute;top:-9px;left:10px;background:#fff;padding:0 6px;font-size:11px;font-weight:600;color:#666;line-height:1;">${b.label}${cbRequired}</div>
                            <div style="display:flex;${cbLayout}width:100%;">${cbOpts}</div>
                        </div>
                    </div>`;

                case 'dropdown':
                    const ddCount = b.dropdowns ? b.dropdowns.length : 1;
                    let ddContentHtml;
                    const ddReqStar = b.required ? ' <span style="color:#BA0C2F;">*</span>' : '';
                    if (ddCount === 1) {
                        const dd = b.dropdowns ? b.dropdowns[0] : { label: 'Dropdown', options: [] };
                        const optionsHtml = (dd.options || []).map(o => `<option>${o}</option>`).join('');
                        ddContentHtml = `<div>
                            <div class="preview-field-label">${dd.label}${ddReqStar}</div>
                            <select class="preview-field-line" style="height:28px;font-size:11px;padding:0 8px;color:#666;cursor:pointer;" disabled>
                                <option value="">Select...</option>
                                ${optionsHtml}
                            </select>
                        </div>`;
                    } else {
                        const cols = b.dropdowns.map(dd => {
                            const optionsHtml = (dd.options || []).map(o => `<option>${o}</option>`).join('');
                            return `<div>
                                <div class="preview-field-label">${dd.label}${ddReqStar}</div>
                                <select class="preview-field-line" style="height:28px;font-size:11px;padding:0 8px;color:#666;cursor:pointer;" disabled>
                                    <option value="">Select...</option>
                                    ${optionsHtml}
                                </select>
                            </div>`;
                        }).join('');
                        ddContentHtml = `<div style="display:grid;grid-template-columns:repeat(${ddCount}, 1fr);gap:10px;">${cols}</div>`;
                    }

                    if (b.showSection) {
                        const ddTitleHtml = b.hideTitle ? '' : `<div class="preview-section-header">${b.sectionTitle || 'Section Title'}</div>`;
                        return `<div class="preview-section">
                            ${ddTitleHtml}
                            ${ddContentHtml}
                        </div>`;
                    } else {
                        return `<div>${ddContentHtml}</div>`;
                    }

                case 'address':
                    const typeSelectorHtml = b.includeTypeSelector ? `
                        <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
                            <span style="font-size:11px;font-weight:600;color:#4a4a4a;">Select Address Type: <span style="color:#BA0C2F;">*</span></span>
                            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#4a4a4a;">
                                <span class="preview-checkbox"></span> Local
                            </label>
                            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#4a4a4a;">
                                <span class="preview-checkbox"></span> Permanent
                            </label>
                            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#4a4a4a;">
                                <span class="preview-checkbox"></span> Billing
                            </label>
                        </div>` : '';
                    const phoneHtml = b.includePhone ? `
                        <div style="margin-top:8px;">
                            <div style="display:flex;align-items:end;gap:10px;">
                                <div style="flex:0 0 auto;">
                                    <div class="preview-field-label">Country Code</div>
                                    <div style="display:flex;align-items:center;gap:6px;">
                                        <div class="preview-field-line" style="margin:0;width:50px;"></div>
                                        <span style="font-style:italic;color:#888;font-size:9px;white-space:nowrap;">(non-US)</span>
                                    </div>
                                </div>
                                <div style="flex:0 0 auto;">
                                    <div class="preview-field-label">Area Code <span style="color:#BA0C2F;">*</span></div>
                                    <div class="preview-field-line" style="margin:0;width:70px;"></div>
                                </div>
                                <div style="flex:1;">
                                    <div class="preview-field-label">Phone Number <span style="color:#BA0C2F;">*</span></div>
                                    <div class="preview-field-line" style="margin:0;"></div>
                                </div>
                                <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#4a4a4a;white-space:nowrap;padding-bottom:2px;">
                                    <span class="preview-checkbox"></span> Make primary phone
                                </label>
                            </div>
                        </div>` : '';
                    return `<div class="preview-section">
                        <div class="preview-section-header">${b.title}</div>
                        ${typeSelectorHtml}
                        <div style="display:grid;grid-template-columns:4fr 1fr;gap:10px;margin-bottom:6px;">
                            <div><div class="preview-field-label">Street Address <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">Apt</div><div class="preview-field-line"></div></div>
                        </div>
                        <div class="preview-row">
                            <div class="col-city"><div class="preview-field-label">City <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div class="col-state"><div class="preview-field-label">State <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">Country <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div class="col-postal"><div class="preview-field-label">Zip Code <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                        </div>
                        ${phoneHtml}
                    </div>`;

                case 'student-info':
                    return `<div class="preview-section">
                        <div class="preview-section-header">${b.title}</div>
                        <!-- Row 1: Name fields -->
                        <div style="display:grid;grid-template-columns:1.2fr 1fr 0.8fr;gap:10px;margin-bottom:8px;">
                            <div><div class="preview-field-label">Last Name <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">First Name <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">Middle Name</div><div class="preview-field-line"></div></div>
                        </div>
                        <!-- Row 2: UGA ID + Email -->
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                            <div>
                                <div class="preview-field-label">UGA ID (810X) Number <span style="color:#BA0C2F;">*</span></div>
                                <div class="preview-field-line"></div>
                            </div>
                            <div>
                                <div class="preview-field-label">Contact Email Address <span style="color:#BA0C2F;">*</span></div>
                                <div class="preview-field-line"></div>
                            </div>
                        </div>
                    </div>`;

                case 'course-info':
                    return `<div class="preview-section">
                        <div class="preview-section-header">${b.title}</div>
                        <!-- Row: CRN, Course Prefix, Course Number, Credit Hours -->
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px;">
                            <div><div class="preview-field-label">CRN <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">Course Prefix <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">Course Number <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                            <div><div class="preview-field-label">Credit Hours <span style="color:#BA0C2F;">*</span></div><div class="preview-field-line"></div></div>
                        </div>
                    </div>`;

                case 'info-paragraph':
                    // Parse markdown (bold, bullets, line breaks) for preview
                    const infoParagraphHtml = markdownToHtml(b.text || '');
                    return `<div style="background:#f5f0eb;border-radius:4px;padding:10px 14px;">
                        <div style="font-size:10px;font-weight:700;color:#4a4a4a;text-transform:uppercase;letter-spacing:0.5px;border-bottom:1px solid #ccc;padding-bottom:6px;margin-bottom:8px;">${b.title}</div>
                        <div style="font-size:11px;color:#4a4a4a;line-height:1.6;">${infoParagraphHtml}</div>
                    </div>`;

                case 'signature':
                    const sigRequired = b.required !== undefined ? b.required : true; // default true for backwards compat
                    const sigReqStar = sigRequired ? ' <span style="color:#BA0C2F;">*</span>' : '';
                    const photoIdBoxHtml = b.includePhotoId ? `
                        <div style="width:180px;height:50px;border:2px dashed #999;border-radius:6px;display:flex;align-items:center;gap:10px;padding:0 12px;background:#fafafa;flex-shrink:0;">
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="2" y="4" width="20" height="16" rx="2"></rect>
                                <circle cx="8" cy="10" r="2"></circle>
                                <path d="M14 10h4"></path>
                                <path d="M14 14h4"></path>
                                <path d="M6 16h4"></path>
                            </svg>
                            <span style="font-size:11px;color:#4a4a4a;font-weight:600;line-height:1.3;">Include copy of<br>Photo ID${sigReqStar}</span>
                        </div>` : '';
                    return `<div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;">
                        <div style="display:flex;flex-direction:column;flex:1;min-width:0;">
                            <div class="preview-signature-row" style="justify-content:flex-start;">
                                <span class="preview-signature-label">${b.label}${sigReqStar}</span>
                                <span class="preview-signature-line"></span>
                            </div>
                            ${b.includeDate ? `<div class="preview-signature-row" style="justify-content:flex-start;"><span class="preview-signature-label">Date${sigReqStar}</span><div class="preview-field-line" style="flex:1;margin:0;"></div></div>` : ''}
                        </div>
                        ${photoIdBoxHtml}
                    </div>`;

                case 'office-use':
                    const approvalHtml = b.includeApprovalCheckboxes ? `
                        <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;flex-wrap:wrap;">
                            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#4a4a4a;">
                                <span class="preview-checkbox"></span> Request Approved
                            </label>
                            <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#4a4a4a;">
                                <span class="preview-checkbox"></span> Request Denied
                            </label>
                            <div style="display:flex;align-items:center;gap:6px;flex:1;min-width:200px;">
                                <span style="font-size:11px;color:#4a4a4a;white-space:nowrap;">Denial Reason:</span>
                                <div class="preview-field-line" style="flex:1;margin:0;"></div>
                            </div>
                        </div>` : '';
                    return `<div class="preview-office-use" style="border:1px solid #000;border-radius:0;">
                        <div class="preview-section-header">${b.title}</div>
                        ${approvalHtml}
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                            ${b.lines.map(l => `<div style="display:flex;align-items:center;gap:6px;"><span style="font-size:11px;font-weight:600;color:#4a4a4a;white-space:nowrap;">${l}:</span><div class="preview-field-line" style="flex:1;margin:0;"></div></div>`).join('')}
                        </div>
                    </div>`;

                case 'footer':
                    return `<div style="text-align:center;font-size:10px;color:#666;font-style:italic;padding-top:10px;border-top:1px solid #e0e0e0;">
                        Revised ${b.revisedMonth} ${b.revisedYear}
                    </div>`;
            }
        }

        function renderProps() {
            const panel = document.getElementById('props');

            // Letterhead selected
            if (selectedId === 'letterhead') {
                panel.innerHTML = `
                    <div class="space-y-3">
                        <p class="text-xs text-gray-500 uppercase font-medium">Letterhead</p>
                        <div>
                            <label class="block text-xs text-gray-500 mb-1">Title</label>
                            <input type="text" value="${letterheadTitle}" onchange="letterheadTitle = this.value; render();"
                                   class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">
                        </div>
                        <p class="text-xs text-gray-400 italic">Address is fixed and cannot be edited.</p>
                    </div>
                `;
                return;
            }

            const b = blocks.find(x => x.id === selectedId);
            if (!b) {
                panel.innerHTML = '<p class="text-sm text-gray-400 italic">Select a block to edit</p>';
                return;
            }

            let html = '<div class="space-y-3">';

            // Move/Delete controls
            html += `<div class="flex gap-1 mb-2">
                <button onclick="moveBlock(-1)" class="flex-1 py-1 text-xs border rounded hover:bg-gray-50">Move Up</button>
                <button onclick="moveBlock(1)" class="flex-1 py-1 text-xs border rounded hover:bg-gray-50">Move Down</button>
                <button onclick="deleteBlock()" class="py-1 px-2 text-xs border rounded text-red-600 hover:bg-red-50">Delete</button>
            </div>`;

            switch(b.type) {
                case 'section':
                case 'student-info':
                case 'course-info':
                    html += field('Title', 'title', b.title);
                    if (b.fieldPrefix !== undefined) html += field('Field Prefix', 'fieldPrefix', b.fieldPrefix);
                    break;
                case 'section-title':
                    html += field('Title', 'title', b.title);
                    html += `<p class="text-xs text-gray-400 mt-1">Text will display uppercase in a grey bar</p>`;
                    break;
                case 'address':
                    html += field('Title', 'title', b.title);
                    html += field('Field Prefix', 'fieldPrefix', b.fieldPrefix);
                    html += `<hr class="my-2">`;
                    html += checkbox('Include Type Selector', 'includeTypeSelector', b.includeTypeSelector);
                    html += checkbox('Include Phone Field', 'includePhone', b.includePhone);
                    break;
                case 'notice':
                    html += field('Title', 'title', b.title);
                    html += `<div>
                        <label class="block text-xs text-gray-500 mb-1">Text</label>
                        <div class="flex gap-1 mb-1">
                            <button onclick="toggleBoldEditor('noticeEditor')" class="px-2 py-0.5 text-xs border rounded bg-white hover:bg-gray-100" title="Bold selected text"><strong>B</strong></button>
                            <span class="text-xs text-gray-400 ml-1">Select text & click B</span>
                        </div>
                        <div id="noticeEditor" contenteditable="true" oninput="updateFromEditor('noticeEditor', 'text')"
                            class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400 min-h-[60px] bg-white">${markdownToHtml(b.text || '')}</div>
                    </div>`;
                    break;
                case 'text-field':
                    // Handle both old format (fields array) and new format (rows array)
                    const tfRows = b.rows || [b.fields || []];
                    const tfColumns = b.columns || (b.fields ? b.fields.length : 1);

                    // Section box toggle
                    html += checkbox('Show Section Box', 'showSection', b.showSection);
                    if (b.showSection) {
                        html += checkbox('Hide Title', 'hideTitle', b.hideTitle);
                        if (!b.hideTitle) {
                            html += field('Section Title', 'sectionTitle', b.sectionTitle || 'Section Title');
                        }
                    }
                    html += `<hr class="my-2">`;

                    // Grid info
                    html += `<div class="flex items-center justify-between mb-2">
                        <p class="text-xs text-gray-500 font-medium">${tfColumns} Column${tfColumns > 1 ? 's' : ''}  ${tfRows.length} Row${tfRows.length > 1 ? 's' : ''}</p>
                        <button onclick="addTextFieldRow()" class="text-xs text-blue-600 hover:text-blue-800">+ Add Row</button>
                    </div>`;

                    // Render each row
                    tfRows.forEach((row, rowIdx) => {
                        html += `<div class="mb-3 p-2 bg-gray-100 rounded border">
                            <div class="flex items-center justify-between mb-2">
                                <p class="text-xs text-gray-500 font-medium">Row ${rowIdx + 1}</p>
                                ${tfRows.length > 1 ? `<button onclick="removeTextFieldRow(${rowIdx})" class="text-xs text-red-500 hover:text-red-700">Remove</button>` : ''}
                            </div>`;
                        row.forEach((f, colIdx) => {
                            html += `<div class="p-2 bg-white rounded border mb-1">
                                <p class="text-xs text-gray-400 mb-1">Field ${colIdx + 1}</p>
                                <div class="mb-2">
                                    <label class="block text-xs text-gray-500 mb-1">Label</label>
                                    <input type="text" value="${f.label}" onchange="updateTextFieldCell(${rowIdx}, ${colIdx}, 'label', this.value)"
                                           class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">Field Name</label>
                                    <input type="text" value="${f.fieldName}" onchange="updateTextFieldCell(${rowIdx}, ${colIdx}, 'fieldName', this.value)"
                                           class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">
                                </div>
                            </div>`;
                        });
                        html += `</div>`;
                    });

                    html += checkbox('Required', 'required', b.required);
                    break;
                case 'textarea':
                    html += field('Label', 'label', b.label);
                    html += field('Field Name', 'fieldName', b.fieldName);
                    html += checkbox('Required', 'required', b.required);
                    html += field('Rows', 'rows', b.rows, 'number');
                    break;
                case 'checkbox':
                    html += field('Label', 'label', b.label);
                    html += checkbox('Required', 'required', b.required);
                    html += `<div class="mb-2">
                        <label class="block text-xs text-gray-500 mb-1">Layout</label>
                        <select onchange="updateProp('layout', this.value)" class="w-full px-2 py-1 text-sm border rounded">
                            <option value="horizontal" ${b.layout === 'horizontal' ? 'selected' : ''}>Horizontal</option>
                            <option value="vertical" ${b.layout === 'vertical' ? 'selected' : ''}>Vertical</option>
                        </select>
                    </div>`;
                    html += `<div class="mb-2"><label class="block text-xs text-gray-500 mb-1">Options</label></div>`;
                    (b.options || []).forEach((opt, i) => {
                        const o = typeof opt === 'string' ? { text: opt, bold: false, hasField: false, fieldRows: 1 } : opt;
                        html += `<div class="p-2 bg-gray-50 rounded border mb-2">
                            <div class="flex items-center gap-1 mb-1">
                                <span class="text-xs text-gray-400">Option ${i + 1}</span>
                                <button onclick="removeCheckboxOption(${i})" class="ml-auto text-xs text-red-500 hover:text-red-700">Remove</button>
                            </div>
                            <div class="flex gap-1 mb-1">
                                <button onclick="toggleBoldCheckboxOption(${i})" class="px-2 py-0.5 text-xs border rounded bg-white hover:bg-gray-100" title="Bold selected text"><strong>B</strong></button>
                                <span class="text-xs text-gray-400">Select text & click B</span>
                            </div>
                            <div id="checkboxOptionEditor_${i}" contenteditable="true" oninput="updateCheckboxOptionFromEditor(${i})"
                                class="w-full px-2 py-1 text-sm border rounded mb-2 focus:outline-none focus:border-gray-400 min-h-[36px] bg-white">${markdownToHtml(o.text)}</div>
                            <div class="flex items-center gap-2">
                                <label class="flex items-center gap-1 text-xs">
                                    <input type="checkbox" ${o.hasField ? 'checked' : ''} onchange="updateCheckboxOption(${i}, 'hasField', this.checked)">
                                    Add fillable field
                                </label>
                                ${o.hasField ? `<label class="flex items-center gap-1 text-xs">
                                    Rows:
                                    <input type="number" min="1" max="5" value="${o.fieldRows || 1}" onchange="updateCheckboxOption(${i}, 'fieldRows', parseInt(this.value))" class="w-12 px-1 py-0.5 text-xs border rounded">
                                </label>` : ''}
                            </div>
                        </div>`;
                    });
                    html += `<button onclick="addCheckboxOption()" class="w-full py-1 text-xs border border-dashed rounded text-gray-500 hover:bg-gray-50">+ Add Option</button>`;
                    break;
                case 'dropdown':
                    // Section box toggle
                    html += checkbox('Show Section Box', 'showSection', b.showSection);
                    if (b.showSection) {
                        html += checkbox('Hide Title', 'hideTitle', b.hideTitle);
                        if (!b.hideTitle) {
                            html += field('Section Title', 'sectionTitle', b.sectionTitle || 'Section Title');
                        }
                    }
                    html += `<hr class="my-2">`;

                    if (b.dropdowns && b.dropdowns.length > 0) {
                        html += `<p class="text-xs text-gray-500 font-medium">${b.dropdowns.length} Dropdown${b.dropdowns.length > 1 ? 's' : ''} in Row</p>`;
                        b.dropdowns.forEach((dd, i) => {
                            html += `<div class="p-2 bg-gray-50 rounded border mb-2">
                                <p class="text-xs text-gray-400 mb-1">Dropdown ${i + 1}</p>
                                <div class="mb-2">
                                    <label class="block text-xs text-gray-500 mb-1">Label</label>
                                    <input type="text" value="${dd.label}" onchange="updateDropdownField(${i}, 'label', this.value)"
                                           class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">
                                </div>
                                <div class="mb-2">
                                    <label class="block text-xs text-gray-500 mb-1">Field Name</label>
                                    <input type="text" value="${dd.fieldName}" onchange="updateDropdownField(${i}, 'fieldName', this.value)"
                                           class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500 mb-1">Options (one per line)</label>
                                    <textarea rows="4" onchange="updateDropdownOptions(${i}, this.value)"
                                           class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">${(dd.options || []).join('\n')}</textarea>
                                </div>
                            </div>`;
                        });
                        html += checkbox('Required', 'required', b.required);
                    }
                    break;
                case 'signature':
                    html += field('Label', 'label', b.label);
                    html += checkbox('Required', 'required', b.required !== undefined ? b.required : true);
                    html += checkbox('Include Date', 'includeDate', b.includeDate);
                    html += checkbox('Include Photo ID Attachment', 'includePhotoId', b.includePhotoId);
                    break;
                case 'info-paragraph':
                    html += field('Title', 'title', b.title);
                    html += `<div>
                        <label class="block text-xs text-gray-500 mb-1">Text</label>
                        <div class="flex gap-1 mb-1 items-center">
                            <button onclick="toggleBoldEditor('infoParagraphEditor')" class="px-2 py-0.5 text-xs border rounded bg-white hover:bg-gray-100" title="Bold selected text"><strong>B</strong></button>
                            <button onclick="toggleBulletEditor('infoParagraphEditor')" class="px-2 py-0.5 text-xs border rounded bg-white hover:bg-gray-100" title="Bullet list"> List</button>
                            <span class="text-xs text-gray-400 ml-1">Select text & click to format</span>
                        </div>
                        <div id="infoParagraphEditor" contenteditable="true" oninput="updateFromEditor('infoParagraphEditor', 'text')"
                            class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400 min-h-[80px] bg-white">${markdownToHtml(b.text || '')}</div>
                    </div>`;
                    break;
                case 'office-use':
                    html += field('Title', 'title', b.title);
                    html += checkbox('Include Approval Checkboxes', 'includeApprovalCheckboxes', b.includeApprovalCheckboxes);
                    html += `<p class="text-xs text-gray-400 mb-2">Shows Request Approved/Denied checkboxes with denial reason field</p>`;
                    html += textarea('Bottom Lines (one per line)', 'lines', b.lines.join('\n'), true);
                    html += `<p class="text-xs text-gray-400">Lines display in 50/50 split layout</p>`;
                    break;
                case 'footer':
                    html += `<div class="mb-2">
                        <label class="block text-xs text-gray-500 mb-1">Revised Month</label>
                        <select onchange="updateProp('revisedMonth', this.value)" class="w-full px-2 py-1 text-sm border rounded">
                            ${['January','February','March','April','May','June','July','August','September','October','November','December'].map(m =>
                                `<option value="${m}" ${b.revisedMonth === m ? 'selected' : ''}>${m}</option>`
                            ).join('')}
                        </select>
                    </div>`;
                    html += field('Revised Year', 'revisedYear', b.revisedYear);
                    break;
            }

            html += '</div>';
            panel.innerHTML = html;
        }

        function field(label, prop, value, type = 'text') {
            return `<div>
                <label class="block text-xs text-gray-500 mb-1">${label}</label>
                <input type="${type}" value="${value}" oninput="updateProp('${prop}', this.value)"
                       class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">
            </div>`;
        }

        function textarea(label, prop, value, isArray = false) {
            return `<div>
                <label class="block text-xs text-gray-500 mb-1">${label}</label>
                <textarea rows="3" oninput="updateProp('${prop}', this.value, ${isArray})"
                       class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:border-gray-400">${value}</textarea>
            </div>`;
        }

        function checkbox(label, prop, checked) {
            return `<label class="flex items-center gap-2 text-sm">
                <input type="checkbox" ${checked ? 'checked' : ''} onchange="updateProp('${prop}', this.checked)">
                ${label}
            </label>`;
        }

        function updateProp(prop, value, isArray = false) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b) return;
            if (isArray) value = value.split('\n').filter(x => x.trim());
            if (prop === 'rows') value = parseInt(value) || 2;
            b[prop] = value;
            renderPreview();
        }

        function updateDropdownField(index, prop, value) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || !b.dropdowns || !b.dropdowns[index]) return;
            b.dropdowns[index][prop] = value;
            renderPreview();
        }

        function updateDropdownOptions(index, value) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || !b.dropdowns || !b.dropdowns[index]) return;
            b.dropdowns[index].options = value.split('\n').filter(x => x.trim());
            renderPreview();
        }

        function updateCheckboxOption(index, prop, value) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || !b.options || !b.options[index]) return;
            // Ensure option is an object
            if (typeof b.options[index] === 'string') {
                b.options[index] = { text: b.options[index], bold: false, italic: false, underline: false };
            }
            b.options[index][prop] = value;
            renderPreview();
        }

        function toggleCheckboxStyle(index, style) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || !b.options || !b.options[index]) return;
            if (typeof b.options[index] === 'string') {
                b.options[index] = { text: b.options[index], bold: false, italic: false, underline: false };
            }
            b.options[index][style] = !b.options[index][style];
            renderPreview();
        }

        function addCheckboxOption() {
            const b = blocks.find(x => x.id === selectedId);
            if (!b) return;
            if (!b.options) b.options = [];
            b.options.push({ text: 'New Option', bold: false, hasField: false, fieldRows: 1 });
            render();
        }

        function removeCheckboxOption(index) {
            const b = blocks.find(x => x.id === selectedId);
            if (!b || !b.options) return;
            b.options.splice(index, 1);
            render();
        }

        function toggleBoldCheckboxOption(index) {
            const editor = document.getElementById('checkboxOptionEditor_' + index);
            if (!editor) return;
            editor.focus();
            document.execCommand('bold', false, null);
            updateCheckboxOptionFromEditor(index);
        }

        function updateCheckboxOptionFromEditor(index) {
            const editor = document.getElementById('checkboxOptionEditor_' + index);
            if (!editor) return;
            const markdown = htmlToMarkdown(editor.innerHTML);
            const b = blocks.find(x => x.id === selectedId);
            if (b && b.options && b.options[index]) {
                if (typeof b.options[index] === 'string') {
                    b.options[index] = { text: markdown, bold: false, hasField: false, fieldRows: 1 };
                } else {
                    b.options[index].text = markdown;
                }
                renderPreview();
            }
        }

        // Convert **markdown** to <strong>HTML</strong> for display
        function markdownToHtml(text) {
            if (!text) return '';
            let html = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            const lines = html.split('\n');
            let inList = false, result = [];
            lines.forEach(line => {
                if (line.trim().startsWith('- ')) {
                    if (!inList) { result.push('<ul style="margin:4px 0 4px 16px;padding:0;">'); inList = true; }
                    result.push('<li style="margin:2px 0;">' + line.trim().substring(2) + '</li>');
                } else {
                    if (inList) { result.push('</ul>'); inList = false; }
                    if (line) result.push(line);
                }
            });
            if (inList) result.push('</ul>');
            html = result.join('<br>').replace(/<br><ul/g, '<ul').replace(/<\/ul><br>/g, '</ul>');
            return html;
        }

        // Convert <strong>HTML</strong> back to **markdown** for storage
        function htmlToMarkdown(html) {
            if (!html) return '';
            const temp = document.createElement('div');
            temp.innerHTML = html;
            // Replace <strong> and <b> with **markdown**
            temp.querySelectorAll('strong, b').forEach(el => {
                el.replaceWith('**' + el.textContent + '**');
            });
            // Replace <li> with "- " prefix
            temp.querySelectorAll('li').forEach(el => {
                const text = document.createTextNode('- ' + el.textContent.trim());
                el.replaceWith(text);
            });
            // Replace <ul> - preserve content with newlines
            temp.querySelectorAll('ul').forEach(el => {
                const items = el.textContent.trim().split('- ').filter(x => x.trim());
                const text = document.createTextNode(items.map(x => '- ' + x.trim()).join('\n'));
                el.replaceWith(text);
            });
            // Replace <br> and <div> with newlines
            temp.querySelectorAll('br').forEach(el => el.replaceWith('\n'));
            temp.querySelectorAll('div').forEach(el => {
                const text = document.createTextNode('\n' + el.textContent);
                el.replaceWith(text);
            });
            let result = temp.textContent || temp.innerText || '';
            result = result.replace(/\n{3,}/g, '\n\n');
            return result.trim();
        }

        // Toggle bold on selected text in contenteditable
        function toggleBoldEditor(editorId) {
            const editor = document.getElementById(editorId);
            if (!editor) return;
            editor.focus();
            document.execCommand('bold', false, null);
            updateFromEditor(editorId, 'text');
        }

        // Toggle bullet list on selected text in contenteditable
        function toggleBulletEditor(editorId) {
            const editor = document.getElementById(editorId);
            if (!editor) return;
            editor.focus();
            document.execCommand('insertUnorderedList', false, null);
            updateFromEditor(editorId, 'text');
        }

        // Update prop from contenteditable editor
        function updateFromEditor(editorId, prop) {
            const editor = document.getElementById(editorId);
            if (!editor) return;
            const markdown = htmlToMarkdown(editor.innerHTML);
            const b = blocks.find(x => x.id === selectedId);
            if (b) {
                b[prop] = markdown;
                // Don't call full render() as it would lose focus
                // Just update the preview
                renderPreview();
            }
        }

        function moveBlock(dir) {
            const idx = blocks.findIndex(x => x.id === selectedId);
            if (idx < 0) return;
            const newIdx = idx + dir;
            if (newIdx < 0 || newIdx >= blocks.length) return;
            [blocks[idx], blocks[newIdx]] = [blocks[newIdx], blocks[idx]];
            render();
        }

        function deleteBlock() {
            blocks = blocks.filter(x => x.id !== selectedId);
            selectedId = null;
            render();
        }

        async function newForm() {
            if (blocks.length) {
                const confirmed = await showConfirm('Start a new form? Any unsaved changes will be lost.', 'New Form');
                if (!confirmed) return;
            }
            blocks = [];
            selectedId = null;
            idCounter = 0;
            currentTemplateId = null;
            currentFormFolder = null;
            letterheadTitle = 'Title';
            document.getElementById('formTitle').value = 'Untitled Form';
            render();
        }

        // Save function - uses RODS API
        async function saveToServer() {
            const title = document.getElementById('formTitle').value;
            const formData = {
                title: title,
                letterheadTitle: letterheadTitle,
                blocks: blocks
            };

            try {
                let response;
                let isNew = !currentTemplateId;
                let folderToSave = currentFormFolder;

                // For new forms, ask which folder to save to
                if (isNew) {
                    // Get all available folders
                    const foldersResponse = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?select=folder&folder=not.is.null`, {
                        headers: getApiHeaders(false),
                        cache: 'no-store'
                    });
                    const foldersData = await foldersResponse.json();
                    const folders = [...new Set(foldersData.map(r => r.folder).filter(f => f))].sort();

                    // Show folder picker (default to current library folder if browsing)
                    folderToSave = await showFolderPicker(folders, 'Save form to folder:');
                    if (folderToSave === undefined) return; // Cancelled
                    currentFormFolder = folderToSave;
                }

                if (currentTemplateId) {
                    // Update existing record
                    response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?id=eq.${currentTemplateId}`, {
                        method: 'PATCH',
                        headers: getApiHeaders(true),
                        cache: 'no-store',
                        body: JSON.stringify({
                            title: title,
                            letterhead_title: letterheadTitle,
                            folder: folderToSave,
                            form_data: formData
                        })
                    });
                } else {
                    // Create new record
                    response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}`, {
                        method: 'POST',
                        headers: getApiHeaders(true),
                        cache: 'no-store',
                        body: JSON.stringify({
                            title: title,
                            letterhead_title: letterheadTitle,
                            folder: folderToSave,
                            form_data: formData
                        })
                    });
                }

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                // PostgREST returns an array for both POST and PATCH with Prefer: return=representation
                const savedRecord = Array.isArray(result) ? result[0] : result;
                currentTemplateId = savedRecord.id;

                // Refresh library list if modal is open
                if (!document.getElementById('libraryModal').classList.contains('hidden')) {
                    loadLibraryList();
                }

                await showSuccess(isNew ? 'Form saved to library!' : 'Form updated!');

            } catch (err) {
                await showAlert('Error saving form: ' + err.message, 'Save Error');
                console.error('Save error:', err);
            }
        }

        // Download as file (backup)
        function downloadTemplate() {
            const data = {
                title: document.getElementById('formTitle').value,
                letterheadTitle: letterheadTitle,
                blocks: blocks
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = data.title.replace(/[^a-z0-9]/gi, '_') + '.json';
            a.click();
        }

        // Library modal functions
        function openLibrary() {
            document.getElementById('libraryModal').classList.remove('hidden');
            currentLibraryFolder = null; // Start at root
            loadLibraryList();
            lucide.createIcons();
        }

        function closeLibrary() {
            document.getElementById('libraryModal').classList.add('hidden');
        }

        async function loadLibraryList() {
            const listEl = document.getElementById('libraryList');
            listEl.innerHTML = '<p class="text-gray-400 text-sm text-center py-8">Loading...</p>';

            // Update breadcrumb
            updateFolderBreadcrumb();

            try {
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?order=updated_at.desc`, {
                    headers: getApiHeaders(false),
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const records = await response.json();

                if (records && records.length > 0) {
                    // Map all records with folder info, filtering out folder placeholders
                    const allTemplates = records
                        .filter(r => r.title !== '__folder_placeholder__')
                        .map(r => ({
                            id: r.id,
                            title: r.title || 'Untitled',
                            folder: r.folder || null,
                            modified: r.updated_at ? new Date(r.updated_at).toLocaleString() : 'Unknown'
                        }));

                    // Also get folders from placeholder records
                    const placeholderFolders = records
                        .filter(r => r.title === '__folder_placeholder__')
                        .map(r => r.folder)
                        .filter(f => f);

                    // Get unique folders at current level
                    const folders = new Set();
                    const templates = [];

                    // Add folders from placeholders
                    placeholderFolders.forEach(folder => {
                        if (currentLibraryFolder === null) {
                            const topFolder = folder.split('/')[0];
                            folders.add(topFolder);
                        } else if (folder.startsWith(currentLibraryFolder + '/')) {
                            const remaining = folder.substring(currentLibraryFolder.length + 1);
                            const nextFolder = remaining.split('/')[0];
                            folders.add(nextFolder);
                        }
                    });

                    allTemplates.forEach(t => {
                        if (currentLibraryFolder === null) {
                            // At root level
                            if (t.folder) {
                                // Get top-level folder name
                                const topFolder = t.folder.split('/')[0];
                                folders.add(topFolder);
                            } else {
                                // Forms without a folder show at root
                                templates.push(t);
                            }
                        } else {
                            // Inside a folder
                            if (t.folder === currentLibraryFolder) {
                                // Exact match - show this form
                                templates.push(t);
                            } else if (t.folder && t.folder.startsWith(currentLibraryFolder + '/')) {
                                // Subfolder - get next level folder name
                                const remaining = t.folder.substring(currentLibraryFolder.length + 1);
                                const nextFolder = remaining.split('/')[0];
                                folders.add(nextFolder);
                            }
                        }
                    });

                    renderLibraryList(listEl, templates, Array.from(folders).sort());
                } else {
                    listEl.innerHTML = '<p class="text-gray-400 text-sm text-center py-8">No saved forms yet. Create a form and click Save to add it to your library.</p>';
                }
            } catch (err) {
                listEl.innerHTML = '<p class="text-red-500 text-sm text-center py-8">Error loading library: ' + err.message + '</p>';
                console.error('Load library error:', err);
            }
        }

        function updateFolderBreadcrumb() {
            const breadcrumbEl = document.getElementById('folderBreadcrumb');
            if (!currentLibraryFolder) {
                breadcrumbEl.innerHTML = `
                    <button onclick="navigateToFolder(null)" class="text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1">
                        <i data-lucide="home" class="w-4 h-4"></i> All Forms
                    </button>
                `;
            } else {
                const parts = currentLibraryFolder.split('/');
                let html = `
                    <button onclick="navigateToFolder(null)" class="text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1">
                        <i data-lucide="home" class="w-4 h-4"></i>
                    </button>
                `;
                let path = '';
                parts.forEach((part, index) => {
                    path = path ? path + '/' + part : part;
                    const isLast = index === parts.length - 1;
                    html += `<span class="text-gray-400">/</span>`;
                    if (isLast) {
                        html += `<span class="text-gray-700 font-medium">${escapeHtml(part)}</span>`;
                    } else {
                        html += `<button onclick="navigateToFolder('${escapeHtml(path)}')" class="text-blue-600 hover:text-blue-800 hover:underline">${escapeHtml(part)}</button>`;
                    }
                });
                breadcrumbEl.innerHTML = html;
            }
            lucide.createIcons();
        }

        function navigateToFolder(folder) {
            currentLibraryFolder = folder;
            loadLibraryList();
        }

        async function createNewFolder() {
            const folderName = await showPrompt('Enter folder name:', 'New Folder');
            if (!folderName) return;

            // Validate folder name (no slashes, reasonable characters)
            if (folderName.includes('/') || folderName.includes('\\')) {
                await showAlert('Folder name cannot contain slashes.', 'Invalid Name');
                return;
            }

            const fullPath = currentLibraryFolder ? currentLibraryFolder + '/' + folderName : folderName;

            // Create a placeholder form to establish the folder
            // We'll create a hidden "__folder_placeholder__" form that won't show in the UI
            try {
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}`, {
                    method: 'POST',
                    headers: getApiHeaders(true),
                    cache: 'no-store',
                    body: JSON.stringify({
                        title: '__folder_placeholder__',
                        letterhead_title: '',
                        folder: fullPath,
                        form_data: { blocks: [], title: '__folder_placeholder__', letterheadTitle: '' }
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                await showSuccess(`Folder "${folderName}" created!`);
                loadLibraryList();
            } catch (err) {
                await showAlert('Error creating folder: ' + err.message, 'Error');
                console.error('Create folder error:', err);
            }
        }

        async function renameFolder(oldPath, oldName) {
            const newName = await showPrompt('Enter new folder name:', 'Rename Folder', oldName);
            if (!newName || newName === oldName) return;

            if (newName.includes('/') || newName.includes('\\')) {
                await showAlert('Folder name cannot contain slashes.', 'Invalid Name');
                return;
            }

            // Build new path
            const pathParts = oldPath.split('/');
            pathParts[pathParts.length - 1] = newName;
            const newPath = pathParts.join('/');

            try {
                // Fetch all forms that have this folder or are in subfolders
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?or=(folder.eq.${encodeURIComponent(oldPath)},folder.like.${encodeURIComponent(oldPath + '/%')})`, {
                    headers: getApiHeaders(false),
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const records = await response.json();

                // Update each record with new folder path
                for (const record of records) {
                    const updatedFolder = record.folder === oldPath
                        ? newPath
                        : newPath + record.folder.substring(oldPath.length);

                    await fetch(`${RODS_API_BASE}/${RODS_TABLE}?id=eq.${record.id}`, {
                        method: 'PATCH',
                        headers: getApiHeaders(true),
                        cache: 'no-store',
                        body: JSON.stringify({ folder: updatedFolder })
                    });
                }

                await showSuccess(`Folder renamed to "${newName}"!`);

                // Update current folder if we were inside the renamed folder
                if (currentLibraryFolder === oldPath) {
                    currentLibraryFolder = newPath;
                } else if (currentLibraryFolder && currentLibraryFolder.startsWith(oldPath + '/')) {
                    currentLibraryFolder = newPath + currentLibraryFolder.substring(oldPath.length);
                }

                loadLibraryList();
            } catch (err) {
                await showAlert('Error renaming folder: ' + err.message, 'Error');
                console.error('Rename folder error:', err);
            }
        }

        async function moveFormToFolder(id, title) {
            // Get all available folders
            try {
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?select=folder&folder=not.is.null`, {
                    headers: getApiHeaders(false),
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const records = await response.json();
                const folders = [...new Set(records.map(r => r.folder).filter(f => f))].sort();

                // Show folder selection modal
                const selectedFolder = await showFolderPicker(folders, `Move "${title}" to folder:`);
                if (selectedFolder === undefined) return; // Cancelled

                // Update the form's folder
                await fetch(`${RODS_API_BASE}/${RODS_TABLE}?id=eq.${id}`, {
                    method: 'PATCH',
                    headers: getApiHeaders(true),
                    cache: 'no-store',
                    body: JSON.stringify({ folder: selectedFolder || null })
                });

                await showSuccess(selectedFolder ? `Moved to "${selectedFolder}"` : 'Moved to root');
                loadLibraryList();
            } catch (err) {
                await showAlert('Error moving form: ' + err.message, 'Error');
                console.error('Move form error:', err);
            }
        }

        // Prompt helper for input dialogs
        function showPrompt(message, title, defaultValue = '') {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-[60] flex items-center justify-center';
                modal.innerHTML = `
                    <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full mx-4">
                        <h3 class="font-semibold text-lg mb-2">${escapeHtml(title)}</h3>
                        <p class="text-gray-600 mb-4">${escapeHtml(message)}</p>
                        <input type="text" id="promptInput" class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-4" value="${escapeHtml(defaultValue)}">
                        <div class="flex justify-end gap-2">
                            <button id="promptCancel" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded">Cancel</button>
                            <button id="promptOk" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                const input = modal.querySelector('#promptInput');
                input.focus();
                input.select();

                const cleanup = (value) => {
                    document.body.removeChild(modal);
                    resolve(value);
                };

                modal.querySelector('#promptCancel').onclick = () => cleanup(null);
                modal.querySelector('#promptOk').onclick = () => cleanup(input.value.trim());
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') cleanup(input.value.trim());
                    if (e.key === 'Escape') cleanup(null);
                };
            });
        }

        // Folder picker modal
        function showFolderPicker(folders, message) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-[60] flex items-center justify-center';

                const folderOptions = folders.map(f => `
                    <button class="w-full text-left px-3 py-2 hover:bg-blue-50 rounded flex items-center gap-2" data-folder="${escapeHtml(f)}">
                        <i data-lucide="folder" class="w-4 h-4 text-blue-500"></i>
                        ${escapeHtml(f)}
                    </button>
                `).join('');

                modal.innerHTML = `
                    <div class="bg-white rounded-lg shadow-xl max-w-sm w-full mx-4 max-h-[70vh] flex flex-col">
                        <div class="p-4 border-b">
                            <h3 class="font-semibold text-lg">${escapeHtml(message)}</h3>
                        </div>
                        <div class="p-2 overflow-y-auto flex-1">
                            <button class="w-full text-left px-3 py-2 hover:bg-gray-50 rounded flex items-center gap-2 border-b mb-2" data-folder="">
                                <i data-lucide="home" class="w-4 h-4 text-gray-500"></i>
                                Root (no folder)
                            </button>
                            ${folderOptions || '<p class="text-gray-400 text-sm text-center py-4">No folders yet. Create one first.</p>'}
                        </div>
                        <div class="p-4 border-t bg-gray-50 flex justify-between">
                            <button id="folderPickerNew" class="px-3 py-1.5 text-sm border border-gray-300 rounded hover:bg-white flex items-center gap-1">
                                <i data-lucide="folder-plus" class="w-4 h-4"></i> New Folder
                            </button>
                            <button id="folderPickerCancel" class="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                lucide.createIcons();

                const cleanup = (value) => {
                    document.body.removeChild(modal);
                    resolve(value);
                };

                modal.querySelectorAll('[data-folder]').forEach(btn => {
                    btn.onclick = () => cleanup(btn.dataset.folder || null);
                });
                modal.querySelector('#folderPickerCancel').onclick = () => cleanup(undefined);
                modal.querySelector('#folderPickerNew').onclick = async () => {
                    const newFolder = await showPrompt('Enter new folder name:', 'New Folder');
                    if (newFolder && !newFolder.includes('/') && !newFolder.includes('\\')) {
                        cleanup(newFolder);
                    }
                };
            });
        }

        function renderLibraryList(listEl, templates, folders = []) {
            let html = '';

            // Render folders first
            if (folders.length > 0) {
                html += folders.map(folder => {
                    const fullPath = currentLibraryFolder ? currentLibraryFolder + '/' + folder : folder;
                    return `
                    <div class="flex items-center justify-between p-3 border rounded hover:bg-blue-50 group cursor-pointer" onclick="navigateToFolder('${escapeHtml(fullPath)}')">
                        <div class="flex items-center gap-2 flex-1">
                            <i data-lucide="folder" class="w-5 h-5 text-blue-500"></i>
                            <div class="font-medium text-gray-800">${escapeHtml(folder)}</div>
                        </div>
                        <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button onclick="event.stopPropagation(); renameFolder('${escapeHtml(fullPath)}', '${escapeHtml(folder)}')" class="p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-100 rounded" title="Rename folder">
                                <i data-lucide="pencil" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                `;
                }).join('');
            }

            // Render forms
            if (templates.length > 0) {
                html += templates.map(t => `
                    <div class="flex items-center justify-between p-3 border rounded hover:bg-gray-50 group">
                        <div class="flex-1 cursor-pointer" onclick="loadFromLibrary('${t.id}')">
                            <div class="font-medium text-gray-800">${escapeHtml(t.title)}</div>
                            <div class="text-xs text-gray-400">Last modified: ${t.modified}</div>
                        </div>
                        <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button onclick="moveFormToFolder('${t.id}', '${escapeHtml(t.title)}')" class="p-1.5 text-gray-500 hover:text-purple-600 hover:bg-purple-50 rounded" title="Move to folder">
                                <i data-lucide="folder-input" class="w-4 h-4"></i>
                            </button>
                            <button onclick="loadFromLibrary('${t.id}')" class="p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded" title="Open">
                                <i data-lucide="folder-open" class="w-4 h-4"></i>
                            </button>
                            <button onclick="downloadFromLibrary('${t.id}')" class="p-1.5 text-gray-500 hover:text-green-600 hover:bg-green-50 rounded" title="Download">
                                <i data-lucide="download" class="w-4 h-4"></i>
                            </button>
                            <button onclick="deleteFromLibrary('${t.id}', '${escapeHtml(t.title)}')" class="p-1.5 text-gray-500 hover:text-red-600 hover:bg-red-50 rounded" title="Delete">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
            }

            if (!html) {
                html = '<p class="text-gray-400 text-sm text-center py-8">This folder is empty.</p>';
            }

            listEl.innerHTML = html;
            lucide.createIcons();
        }

        async function loadFromLibrary(id) {
            if (blocks.length) {
                const confirmed = await showConfirm('Load this form? Any unsaved changes will be lost.', 'Load Form');
                if (!confirmed) return;
            }

            try {
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?id=eq.${id}`, {
                    headers: getApiHeaders(false),
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const records = await response.json();

                if (records && records.length > 0) {
                    const record = records[0];
                    const formData = record.form_data;

                    document.getElementById('formTitle').value = formData.title || record.title || 'Untitled Form';
                    letterheadTitle = formData.letterheadTitle || record.letterhead_title || 'Title';
                    blocks = formData.blocks || [];
                    idCounter = Math.max(0, ...blocks.map(b => b.id || 0));
                    currentTemplateId = record.id;
                    currentFormFolder = record.folder || null;
                    selectedId = null;
                    render();
                    closeLibrary();
                } else {
                    await showAlert('Form not found', 'Load Error');
                }
            } catch (err) {
                await showAlert('Error loading form: ' + err.message, 'Load Error');
                console.error('Load error:', err);
            }
        }

        async function downloadFromLibrary(id) {
            try {
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?id=eq.${id}`, {
                    headers: getApiHeaders(false),
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const records = await response.json();

                if (records && records.length > 0) {
                    const data = records[0].form_data;
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = (data.title || 'form').replace(/[^a-z0-9]/gi, '_') + '.json';
                    a.click();
                }
            } catch (err) {
                await showAlert('Error downloading: ' + err.message, 'Download Error');
                console.error('Download error:', err);
            }
        }

        async function deleteFromLibrary(id, title) {
            const confirmed = await showConfirm('Delete "' + title + '"? This cannot be undone.', 'Delete Form');
            if (!confirmed) return;

            try {
                const response = await fetch(`${RODS_API_BASE}/${RODS_TABLE}?id=eq.${id}`, {
                    method: 'DELETE',
                    headers: getApiHeaders(false),
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                if (currentTemplateId === id) {
                    currentTemplateId = null;
                }
                await showSuccess('Form deleted successfully');
                loadLibraryList();

            } catch (err) {
                await showAlert('Error deleting form: ' + err.message, 'Delete Error');
                console.error('Delete error:', err);
            }
        }

        function loadFromFile() {
            document.getElementById('fileInput').click();
        }

        function handleLoad(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                const data = JSON.parse(ev.target.result);
                document.getElementById('formTitle').value = data.title || 'Untitled Form';
                letterheadTitle = data.letterheadTitle || 'Title';
                blocks = data.blocks || [];
                idCounter = Math.max(0, ...blocks.map(b => b.id || 0));
                currentTemplateId = null; // Imported files get a new ID when saved
                currentFormFolder = null; // Imported files start with no folder
                selectedId = null;
                render();
                closeLibrary();
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Helper function to convert SVG to PNG data URL
        async function svgToPng(svgUrl, width, height) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = width * 2; // 2x for better quality
                    canvas.height = height * 2;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(2, 2);
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(blob => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(blob);
                    }, 'image/png');
                };
                img.onerror = reject;
                img.src = svgUrl;
            });
        }

        async function exportPDF() {
            const { PDFDocument, StandardFonts, rgb } = PDFLib;
            const pdf = await PDFDocument.create();
            const form = pdf.getForm();

            // Accessibility: Document metadata
            const formTitleText = document.getElementById('formTitle').value || 'Untitled Form';
            pdf.setTitle(formTitleText);
            pdf.setAuthor('UGA Office of the Registrar');
            pdf.setSubject(formTitleText);
            pdf.setCreator('REGI Form Builder');

            // Accessibility: Document language
            try {
                pdf.catalog.set(PDFLib.PDFName.of('Lang'), PDFLib.PDFString.of('en-US'));
            } catch(e) { console.warn('Could not set document language:', e); }

            const font = await pdf.embedFont(StandardFonts.Helvetica);
            const fontBold = await pdf.embedFont(StandardFonts.HelveticaBold);
            const fontSerif = await pdf.embedFont(StandardFonts.TimesRoman);
            const red = rgb(186/255, 12/255, 47/255);
            const gray = rgb(74/255, 74/255, 74/255);

            // Page dimensions (8.5 x 11 inches at 72 dpi)
            const pageWidth = 612;
            const pageHeight = 792;

            // Margins matching preview: padding: 0.5in 0.6in 0.4in (top, sides, bottom)
            const mTop = 36;    // 0.5in * 72
            const mSide = 43;   // 0.6in * 72
            const mBottom = 29; // 0.4in * 72
            const contentWidth = pageWidth - (mSide * 2);

            // Standardized spacing tokens (match preview CSS)
            const BLOCK_GAP = 10;       // Space between blocks (matches .block-item margin-bottom)
            const LABEL_GAP = 4;        // Space between label text and field below
            const FIELD_HEIGHT = 18;    // Standard fillable field height
            const SECTION_PAD = 10;     // Inner padding from section box edges
            const GRID_GAP = 10;        // Gap between grid columns
            const ROW_GAP = 6;          // Vertical gap between field rows within a text-field block
            const FIELD_ROW_GAP = 12;   // Vertical gap between distinct label+field rows in hardcoded sections

            // Load and embed the logo
            let logoImage = null;
            try {
                const logoData = await svgToPng('../images/OfficeRegistrar_logo_Horizontal_FC.svg', 219, 60);
                logoImage = await pdf.embedPng(logoData);
            } catch (e) {
                console.warn('Could not load logo:', e);
            }

            // Track current page and y position
            let currentPage = pdf.addPage([pageWidth, pageHeight]);
            currentPage.node.set(PDFLib.PDFName.of('Tabs'), PDFLib.PDFName.of('S'));
            let y = pageHeight - mTop;

            // Helper to check if we need a new page and create one if needed
            function ensureSpace(neededHeight) {
                if (y - neededHeight < mBottom) {
                    currentPage = pdf.addPage([pageWidth, pageHeight]);
                    currentPage.node.set(PDFLib.PDFName.of('Tabs'), PDFLib.PDFName.of('S'));
                    y = pageHeight - mTop;
                    return true;
                }
                return false;
            }

            // Shared text wrapping helper  returns array of line strings
            function wrapText(text, maxWidth, useFont, fontSize) {
                const words = text.split(' ');
                const lines = [];
                let current = '';
                words.forEach(word => {
                    const test = current ? current + ' ' + word : word;
                    if (useFont.widthOfTextAtSize(test, fontSize) > maxWidth && current) {
                        lines.push(current);
                        current = word;
                    } else {
                        current = test;
                    }
                });
                if (current) lines.push(current);
                return lines.length ? lines : [''];
            }

            // Accessibility: Set tooltip and required flag on PDF form fields
            function setFieldA11y(field, tooltip, isRequired) {
                try {
                    const dict = field.acroField.dict;
                    dict.set(PDFLib.PDFName.of('TU'), PDFLib.PDFHexString.fromText(tooltip));
                    if (isRequired) {
                        const flags = dict.get(PDFLib.PDFName.of('Ff'));
                        const currentFlags = flags ? flags.asNumber() : 0;
                        dict.set(PDFLib.PDFName.of('Ff'), PDFLib.PDFNumber.of(currentFlags | 2));
                    }
                } catch(e) { /* accessibility enhancement - non-critical */ }
            }

            // --- LETTERHEAD ---
            // Logo (top left)
            const logoWidth = 150;
            const logoHeight = 41;
            if (logoImage) {
                currentPage.drawImage(logoImage, {
                    x: mSide,
                    y: y - logoHeight + 10,
                    width: logoWidth,
                    height: logoHeight
                });
            }

            // Title (right aligned, underlined)
            const titleWidth = fontSerif.widthOfTextAtSize(letterheadTitle, 12);
            const titleX = pageWidth - mSide - titleWidth;
            currentPage.drawText(letterheadTitle, { x: titleX, y: y, size: 12, font: fontSerif });
            currentPage.drawLine({ start: { x: titleX, y: y - 2 }, end: { x: titleX + titleWidth, y: y - 2 }, thickness: 0.5, color: rgb(0, 0, 0) });
            y -= 14;

            // Address (right aligned)
            const addressLines = [
                'University of Georgia',
                'Office of the Registrar',
                'Holmes-Hunter Academic Building',
                'Athens, Georgia 30602'
            ];
            addressLines.forEach(line => {
                const lineWidth = fontSerif.widthOfTextAtSize(line, 9);
                currentPage.drawText(line, { x: pageWidth - mSide - lineWidth, y: y, size: 9, font: fontSerif, color: gray });
                y -= 11;
            });

            // Line under letterhead
            y -= 8;
            currentPage.drawLine({ start: { x: mSide, y: y }, end: { x: pageWidth - mSide, y: y }, thickness: 0.5, color: rgb(0.8, 0.8, 0.8) });
            y -= 16;

            // --- BLOCKS ---
            for (const b of blocks) {
                switch(b.type) {
                    case 'section':
                        const secTitleLines = wrapText(b.title.toUpperCase(), contentWidth - SECTION_PAD * 2, fontBold, 11);
                        const sectionH = 32 + (secTitleLines.length - 1) * 14;
                        ensureSpace(sectionH + BLOCK_GAP);
                        currentPage.drawRectangle({ x: mSide, y: y - sectionH, width: contentWidth, height: sectionH, color: rgb(0.98, 0.98, 0.98), borderColor: rgb(0.89, 0.89, 0.89), borderWidth: 0.5 });
                        secTitleLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 14 - i * 14, size: 11, font: fontBold, color: red });
                        });
                        const secUnderlineY = y - 20 - (secTitleLines.length - 1) * 14;
                        currentPage.drawLine({ start: { x: mSide + SECTION_PAD, y: secUnderlineY }, end: { x: pageWidth - mSide - SECTION_PAD, y: secUnderlineY }, thickness: 0.5, color: rgb(0.88, 0.88, 0.88) });
                        y -= sectionH + BLOCK_GAP;
                        break;

                    case 'section-title':
                        const stTitleLines = wrapText(b.title.toUpperCase(), contentWidth - SECTION_PAD * 2, font, 10);
                        const stH = 22 + (stTitleLines.length - 1) * 13;
                        ensureSpace(stH + BLOCK_GAP);
                        currentPage.drawRectangle({ x: mSide, y: y - stH, width: contentWidth, height: stH, color: rgb(0.4, 0.4, 0.4) });
                        stTitleLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 15 - i * 13, size: 10, font: font, color: rgb(1, 1, 1) });
                        });
                        y -= stH + BLOCK_GAP;
                        break;

                    case 'notice':
                        // Word-wrap notice text
                        const noticeText = b.text || '';
                        const noticeMaxWidth = contentWidth - 24;
                        const noticeTitleWidth = fontBold.widthOfTextAtSize(b.title, 9) + 4;
                        const noticeWords = noticeText.replace(/\*\*/g, '').split(' ');
                        let noticeLines = [];
                        let noticeLine = '';
                        let firstLine = true;
                        noticeWords.forEach(word => {
                            const testLine = noticeLine ? noticeLine + ' ' + word : word;
                            const lineWidth = font.widthOfTextAtSize(testLine, 9) + (firstLine ? noticeTitleWidth : 0);
                            if (lineWidth > noticeMaxWidth && noticeLine) {
                                noticeLines.push({ text: noticeLine, isFirst: firstLine });
                                noticeLine = word;
                                firstLine = false;
                            } else {
                                noticeLine = testLine;
                            }
                        });
                        if (noticeLine) noticeLines.push({ text: noticeLine, isFirst: firstLine });

                        const noticeLineHeight = 12;
                        const noticeH = Math.max(28, 16 + noticeLines.length * noticeLineHeight);
                        ensureSpace(noticeH + 8);
                        currentPage.drawRectangle({ x: mSide, y: y - noticeH, width: contentWidth, height: noticeH, color: rgb(1, 0.97, 0.96) });
                        currentPage.drawRectangle({ x: mSide, y: y - noticeH, width: 4, height: noticeH, color: red });

                        let noticeY = y - 11;
                        noticeLines.forEach((line, idx) => {
                            let noticeX = mSide + 12;
                            if (line.isFirst) {
                                currentPage.drawText(b.title, { x: noticeX, y: noticeY, size: 9, font: fontBold });
                                noticeX += noticeTitleWidth;
                            }
                            // Render text with **bold** support
                            const parts = line.text.split(/(\*\*[^*]+\*\*)/g);
                            parts.forEach(part => {
                                if (part.startsWith('**') && part.endsWith('**')) {
                                    const boldText = part.slice(2, -2);
                                    currentPage.drawText(boldText, { x: noticeX, y: noticeY, size: 9, font: fontBold });
                                    noticeX += fontBold.widthOfTextAtSize(boldText, 9);
                                } else if (part) {
                                    currentPage.drawText(part, { x: noticeX, y: noticeY, size: 9, font: font });
                                    noticeX += font.widthOfTextAtSize(part, 9);
                                }
                            });
                            noticeY -= noticeLineHeight;
                        });
                        y -= noticeH + BLOCK_GAP;
                        break;

                    case 'text-field':
                        // Handle both old format (fields array) and new format (rows array)
                        const tfAllRows = b.rows || [b.fields || [{ label: b.label || 'Field', fieldName: b.fieldName || 'field' }]];
                        const tfColCount = b.columns || (b.fields ? b.fields.length : 1);
                        const tfGap = GRID_GAP;
                        const tfSecTitleLines = (b.showSection && !b.hideTitle) ? wrapText((b.sectionTitle || 'Section Title').toUpperCase(), contentWidth - SECTION_PAD * 2, fontBold, 11) : [];
                        const tfHeaderHeight = tfSecTitleLines.length > 0 ? 26 + (tfSecTitleLines.length - 1) * 14 : 0;
                        const tfInnerX = b.showSection ? mSide + SECTION_PAD : mSide;
                        const tfInnerW = b.showSection ? contentWidth - (SECTION_PAD * 2) : contentWidth;
                        const tfFieldW = (tfInnerW - (tfGap * (tfColCount - 1))) / tfColCount;

                        // Helper function to wrap label text
                        function wrapLabel(label, maxWidth) {
                            const words = label.split(' ');
                            const lines = [];
                            let currentLine = '';
                            words.forEach(word => {
                                // If word itself is too long, break it by characters
                                if (fontBold.widthOfTextAtSize(word, 9) > maxWidth) {
                                    if (currentLine) {
                                        lines.push(currentLine);
                                        currentLine = '';
                                    }
                                    let chars = '';
                                    for (let c of word) {
                                        if (fontBold.widthOfTextAtSize(chars + c, 9) > maxWidth && chars) {
                                            lines.push(chars);
                                            chars = c;
                                        } else {
                                            chars += c;
                                        }
                                    }
                                    if (chars) currentLine = chars;
                                } else {
                                    const test = currentLine ? currentLine + ' ' + word : word;
                                    if (fontBold.widthOfTextAtSize(test, 9) > maxWidth && currentLine) {
                                        lines.push(currentLine);
                                        currentLine = word;
                                    } else {
                                        currentLine = test;
                                    }
                                }
                            });
                            if (currentLine) lines.push(currentLine);
                            return lines.length > 0 ? lines : [''];
                        }

                        // Pre-calculate wrapped labels and row heights
                        const tfRowData = tfAllRows.map(row => {
                            const wrappedLabels = row.map(f => wrapLabel(f.label, tfFieldW - 10)); // -10 for some padding
                            const maxLines = Math.max(...wrappedLabels.map(l => l.length));
                            const labelHeight = maxLines * 11; // 11px per line
                            return { row, wrappedLabels, maxLines, labelHeight, rowHeight: labelHeight + 24 }; // 24 = gap + field height
                        });

                        const tfTotalRowsHeight = tfRowData.reduce((sum, rd) => sum + rd.rowHeight + ROW_GAP, 0);
                        const tfTotalHeight = tfHeaderHeight + tfTotalRowsHeight + (b.showSection ? SECTION_PAD : 0);

                        ensureSpace(tfTotalHeight + BLOCK_GAP);

                        if (b.showSection) {
                            // Draw section box
                            currentPage.drawRectangle({ x: mSide, y: y - tfTotalHeight, width: contentWidth, height: tfTotalHeight, color: rgb(0.98, 0.98, 0.98), borderColor: rgb(0.89, 0.89, 0.89), borderWidth: 0.5 });
                            // Draw section title (unless hidden)
                            if (!b.hideTitle) {
                                tfSecTitleLines.forEach((line, i) => {
                                    currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 14 - i * 14, size: 11, font: fontBold, color: red });
                                });
                                const tfUnderlineY = y - 20 - (tfSecTitleLines.length - 1) * 14;
                                currentPage.drawLine({ start: { x: mSide + SECTION_PAD, y: tfUnderlineY }, end: { x: pageWidth - mSide - SECTION_PAD, y: tfUnderlineY }, thickness: 0.5, color: rgb(0.88, 0.88, 0.88) });
                                y -= tfHeaderHeight;
                            }
                        }

                        // Render each row
                        tfRowData.forEach(({ row, wrappedLabels, maxLines, labelHeight }, rowIdx) => {
                            y -= ROW_GAP; // Margin above labels
                            const labelStartY = y;

                            // Draw wrapped labels for each field
                            row.forEach((f, colIdx) => {
                                const labelX = tfInnerX + colIdx * (tfFieldW + tfGap);
                                const lines = wrappedLabels[colIdx];
                                let labelY = labelStartY;
                                lines.forEach((line, lineIdx) => {
                                    currentPage.drawText(line, { x: labelX, y: labelY, size: 9, font: fontBold, color: gray });
                                    // Add required asterisk to last line of this label
                                    if (b.required && lineIdx === lines.length - 1) {
                                        currentPage.drawText(' *', { x: labelX + fontBold.widthOfTextAtSize(line, 9), y: labelY, size: 9, font: fontBold, color: red });
                                    }
                                    labelY -= 11;
                                });
                            });

                            y -= labelHeight; // Move past all label lines
                            y -= LABEL_GAP; // Gap between label and field

                            // Draw fields
                            row.forEach((f, colIdx) => {
                                const fieldX = tfInnerX + colIdx * (tfFieldW + tfGap);
                                const tfField = form.createTextField(f.fieldName + '_' + b.id + '_r' + rowIdx);
                                tfField.addToPage(currentPage, { x: fieldX, y: y - FIELD_HEIGHT + 2, width: tfFieldW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                                setFieldA11y(tfField, f.label, b.required);
                            });
                            y -= FIELD_HEIGHT + 2;
                        });

                        if (b.showSection) {
                            y -= SECTION_PAD; // Bottom padding for section box
                        }
                        break;

                    case 'textarea':
                        // Wrap the label text
                        const taLabelText = b.label + (b.required ? ' *' : '');
                        const taLabelMaxWidth = contentWidth;
                        const taLabelWords = b.label.split(' ');
                        let taLabelLines = [];
                        let taLabelCurrent = '';
                        taLabelWords.forEach(word => {
                            const test = taLabelCurrent ? taLabelCurrent + ' ' + word : word;
                            if (fontBold.widthOfTextAtSize(test, 10) > taLabelMaxWidth && taLabelCurrent) {
                                taLabelLines.push(taLabelCurrent);
                                taLabelCurrent = word;
                            } else {
                                taLabelCurrent = test;
                            }
                        });
                        if (taLabelCurrent) taLabelLines.push(taLabelCurrent);
                        if (taLabelLines.length === 0) taLabelLines.push('');

                        const taLabelHeight = taLabelLines.length * 14;
                        const taFieldH = b.rows * FIELD_HEIGHT;
                        const taHeight = taFieldH + taLabelHeight + LABEL_GAP + ROW_GAP;
                        ensureSpace(taHeight + BLOCK_GAP);
                        y -= ROW_GAP; // Margin above label

                        // Render wrapped label lines
                        taLabelLines.forEach((line, idx) => {
                            let labelX = mSide;
                            currentPage.drawText(line, { x: labelX, y, size: 10, font: fontBold, color: gray });
                            // Add required asterisk to last line
                            if (b.required && idx === taLabelLines.length - 1) {
                                currentPage.drawText(' *', { x: labelX + fontBold.widthOfTextAtSize(line, 10), y, size: 10, font: fontBold, color: red });
                            }
                            y -= 14;
                        });

                        y += 14; // Undo last line decrement
                        y -= LABEL_GAP; // Gap between label and field
                        const ta = form.createTextField(b.fieldName + '_' + b.id);
                        ta.enableMultiline();
                        ta.addToPage(currentPage, { x: mSide, y: y - taFieldH, width: contentWidth, height: taFieldH, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        ta.setFontSize(11);
                        setFieldA11y(ta, b.label, b.required);
                        y -= taFieldH + BLOCK_GAP;
                        break;

                    case 'checkbox':
                        const cbOptions = b.options || [];
                        const isVertical = b.layout === 'vertical';
                        const cbTextMaxWidth = contentWidth - 36; // Available width for text (minus margins and checkbox)

                        // Helper function to calculate wrapped lines for checkbox text
                        function getCheckboxTextLines(text, maxWidth) {
                            const words = text.replace(/\*\*/g, '').split(' ');
                            let lines = [];
                            let currentLine = '';
                            words.forEach(word => {
                                const testLine = currentLine ? currentLine + ' ' + word : word;
                                const lineWidth = font.widthOfTextAtSize(testLine, 9);
                                if (lineWidth > maxWidth && currentLine) {
                                    lines.push(currentLine);
                                    currentLine = word;
                                } else {
                                    currentLine = testLine;
                                }
                            });
                            if (currentLine) lines.push(currentLine);
                            return lines.length || 1;
                        }

                        // Calculate total height including multi-row fields and text wrapping
                        let totalCbHeight = 24; // Base padding
                        cbOptions.forEach(opt => {
                            const text = typeof opt === 'string' ? opt : opt.text;
                            const rows = typeof opt === 'object' ? (opt.fieldRows || 1) : 1;
                            const hasField = typeof opt === 'object' && opt.hasField;
                            const textLines = getCheckboxTextLines(text, hasField ? cbTextMaxWidth * 0.4 : cbTextMaxWidth);
                            const textHeight = textLines * 12;
                            const fieldHeight = hasField && rows > 1 ? (rows * 14 + 8) : 20;
                            totalCbHeight += Math.max(textHeight, fieldHeight);
                        });
                        const cbBoxHeight = isVertical ? totalCbHeight : 50;
                        ensureSpace(cbBoxHeight + 10);

                        // Draw bordered box with label
                        currentPage.drawRectangle({ x: mSide, y: y - cbBoxHeight, width: contentWidth, height: cbBoxHeight, borderWidth: 1, borderColor: rgb(0.75, 0.75, 0.75) });
                        // Label background (wider if required indicator)
                        const cbLabelText = b.label + (b.required ? ' *' : '');
                        const labelWidth = fontBold.widthOfTextAtSize(b.label, 9) + (b.required ? 12 : 0) + 8;
                        currentPage.drawRectangle({ x: mSide + 8, y: y - 5, width: labelWidth, height: 10, color: rgb(1, 1, 1) });
                        currentPage.drawText(b.label, { x: mSide + 12, y: y - 3, size: 9, font: fontBold, color: gray });
                        if (b.required) {
                            currentPage.drawText(' *', { x: mSide + 12 + fontBold.widthOfTextAtSize(b.label, 9), y: y - 3, size: 9, font: fontBold, color: red });
                        }

                        let cbX = mSide + 10;
                        let cbY = y - 14;
                        const standardFieldWidth = contentWidth - 150; // Standardized width

                        // Helper to wrap checkbox text into lines (preserves **bold** markers)
                        function wrapCheckboxText(text, maxWidth, useFont) {
                            const words = text.split(' ');
                            let lines = [];
                            let currentLine = '';
                            words.forEach(word => {
                                const testLine = currentLine ? currentLine + ' ' + word : word;
                                // Calculate width without bold markers
                                const plainTest = testLine.replace(/\*\*/g, '');
                                const lineWidth = useFont.widthOfTextAtSize(plainTest, 9);
                                if (lineWidth > maxWidth && currentLine) {
                                    lines.push(currentLine);
                                    currentLine = word;
                                } else {
                                    currentLine = testLine;
                                }
                            });
                            if (currentLine) lines.push(currentLine);
                            return lines;
                        }

                        cbOptions.forEach((opt, i) => {
                            const text = typeof opt === 'string' ? opt : opt.text;
                            const isBold = typeof opt === 'object' && opt.bold;
                            const hasField = typeof opt === 'object' && opt.hasField;
                            const fieldRows = typeof opt === 'object' ? (opt.fieldRows || 1) : 1;
                            const fieldHeight = fieldRows * 14;

                            const cb = form.createCheckBox(b.fieldName + '_' + i + '_' + b.id);
                            cb.addToPage(currentPage, { x: cbX, y: cbY - 10, width: 12, height: 12 });
                            setFieldA11y(cb, text.replace(/\*\*/g, ''), b.required);

                            // Calculate wrapped lines for this checkbox text
                            const textStartX = cbX + 16;
                            const availableWidth = hasField ? cbTextMaxWidth * 0.4 : cbTextMaxWidth;
                            const useFont = isBold ? fontBold : font;
                            const wrappedLines = wrapCheckboxText(text, availableWidth, useFont);
                            const lineHeight = 12;

                            // Render each wrapped line with inline bold support
                            let lineY = cbY - 8;
                            wrappedLines.forEach((line, lineIdx) => {
                                let textX = textStartX;
                                if (isBold) {
                                    // Entire option is bold
                                    currentPage.drawText(line, { x: textX, y: lineY, size: 9, font: fontBold, color: gray });
                                } else {
                                    // Check for inline **bold** markers
                                    const parts = line.split(/(\*\*[^*]+\*\*)/g);
                                    parts.forEach(part => {
                                        if (part.startsWith('**') && part.endsWith('**')) {
                                            const boldText = part.slice(2, -2);
                                            currentPage.drawText(boldText, { x: textX, y: lineY, size: 9, font: fontBold, color: gray });
                                            textX += fontBold.widthOfTextAtSize(boldText, 9);
                                        } else if (part) {
                                            currentPage.drawText(part, { x: textX, y: lineY, size: 9, font: font, color: gray });
                                            textX += font.widthOfTextAtSize(part, 9);
                                        }
                                    });
                                }
                                lineY -= lineHeight;
                            });

                            // Calculate total width of first line for field positioning (strip bold markers)
                            const firstLineWidth = useFont.widthOfTextAtSize((wrappedLines[0] || '').replace(/\*\*/g, ''), 9);

                            // Add fillable field if enabled
                            if (hasField) {
                                const fieldX = textStartX + firstLineWidth + 8;
                                const optField = form.createTextField(b.fieldName + '_field_' + i + '_' + b.id);
                                if (fieldRows > 1) {
                                    optField.enableMultiline();
                                }
                                optField.addToPage(currentPage, { x: fieldX, y: cbY - fieldHeight + 4, width: standardFieldWidth - firstLineWidth, height: fieldHeight, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                                if (fieldRows > 1) {
                                    optField.setFontSize(11);
                                }
                                setFieldA11y(optField, text.replace(/\*\*/g, '') + ' (details)', false);
                            }

                            if (isVertical) {
                                const textRowHeight = wrappedLines.length * lineHeight;
                                const fieldRowHeight = hasField && fieldRows > 1 ? (fieldRows * 14 + 8) : 20;
                                cbY -= Math.max(textRowHeight, fieldRowHeight);
                            } else {
                                cbX += firstLineWidth + (hasField ? standardFieldWidth - firstLineWidth + 20 : 36);
                            }
                        });
                        y -= cbBoxHeight + BLOCK_GAP;
                        break;

                    case 'dropdown':
                        const ddFields = b.dropdowns || [];
                        const ddFieldCount = ddFields.length;
                        const ddFieldH = 38;
                        const ddSecTitleLines = (b.showSection && !b.hideTitle) ? wrapText((b.sectionTitle || 'Section Title').toUpperCase(), contentWidth - SECTION_PAD * 2, fontBold, 11) : [];
                        const ddHeaderHeight = ddSecTitleLines.length > 0 ? 26 + (ddSecTitleLines.length - 1) * 14 : 0;
                        const ddTotalHeight = ddHeaderHeight + ddFieldH + (b.showSection ? SECTION_PAD : 0);
                        const ddInnerX = b.showSection ? mSide + SECTION_PAD : mSide;
                        const ddInnerW = b.showSection ? contentWidth - (SECTION_PAD * 2) : contentWidth;
                        ensureSpace(ddTotalHeight + BLOCK_GAP);

                        if (b.showSection) {
                            // Draw section box
                            currentPage.drawRectangle({ x: mSide, y: y - ddTotalHeight, width: contentWidth, height: ddTotalHeight, color: rgb(0.98, 0.98, 0.98), borderColor: rgb(0.89, 0.89, 0.89), borderWidth: 0.5 });
                            // Draw section title (unless hidden)
                            if (!b.hideTitle) {
                                ddSecTitleLines.forEach((line, i) => {
                                    currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 14 - i * 14, size: 11, font: fontBold, color: red });
                                });
                                const ddUnderlineY = y - 20 - (ddSecTitleLines.length - 1) * 14;
                                currentPage.drawLine({ start: { x: mSide + SECTION_PAD, y: ddUnderlineY }, end: { x: pageWidth - mSide - SECTION_PAD, y: ddUnderlineY }, thickness: 0.5, color: rgb(0.88, 0.88, 0.88) });
                                y -= ddHeaderHeight;
                            }
                        }

                        if (ddFieldCount === 1) {
                            const dd = ddFields[0];
                            y -= ROW_GAP;
                            currentPage.drawText(dd.label, { x: ddInnerX, y, size: 10, font: fontBold, color: gray });
                            if (b.required) {
                                currentPage.drawText(' *', { x: ddInnerX + fontBold.widthOfTextAtSize(dd.label, 10), y, size: 10, font: fontBold, color: red });
                            }
                            y -= LABEL_GAP;
                            const ddrop = form.createDropdown(dd.fieldName + '_' + b.id);
                            ddrop.addOptions(dd.options || []);
                            ddrop.addToPage(currentPage, { x: ddInnerX, y: y - FIELD_HEIGHT, width: ddInnerW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                            setFieldA11y(ddrop, dd.label, b.required);
                            y -= FIELD_HEIGHT + LABEL_GAP;
                        } else {
                            const ddColW = (ddInnerW - (ddFieldCount - 1) * GRID_GAP) / ddFieldCount;
                            y -= ROW_GAP;
                            ddFields.forEach((dd, i) => {
                                const xOff = ddInnerX + i * (ddColW + GRID_GAP);
                                currentPage.drawText(dd.label, { x: xOff, y, size: 10, font: fontBold, color: gray });
                                if (b.required) {
                                    currentPage.drawText(' *', { x: xOff + fontBold.widthOfTextAtSize(dd.label, 10), y, size: 10, font: fontBold, color: red });
                                }
                            });
                            y -= LABEL_GAP;
                            ddFields.forEach((dd, i) => {
                                const xOff = ddInnerX + i * (ddColW + GRID_GAP);
                                const ddrop = form.createDropdown(dd.fieldName + '_' + b.id);
                                ddrop.addOptions(dd.options || []);
                                ddrop.addToPage(currentPage, { x: xOff, y: y - FIELD_HEIGHT, width: ddColW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                                setFieldA11y(ddrop, dd.label, b.required);
                            });
                            y -= FIELD_HEIGHT + LABEL_GAP;
                        }

                        if (b.showSection) {
                            y -= SECTION_PAD; // Bottom padding for section box
                        }
                        break;

                    case 'address':
                        const addrTitleLines = wrapText(b.title.toUpperCase(), contentWidth - SECTION_PAD * 2, fontBold, 11);
                        const addrHeaderExtra = (addrTitleLines.length - 1) * 14;
                        const addrTypeH = b.includeTypeSelector ? 22 : 0;
                        const addrH = (b.includePhone ? 138 : 108) + addrTypeH + addrHeaderExtra;
                        ensureSpace(addrH + BLOCK_GAP);
                        currentPage.drawRectangle({ x: mSide, y: y - addrH, width: contentWidth, height: addrH, color: rgb(0.98, 0.98, 0.98), borderColor: rgb(0.89, 0.89, 0.89), borderWidth: 0.5 });
                        addrTitleLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 14 - i * 14, size: 11, font: fontBold, color: red });
                        });
                        const addrUnderlineY = y - 20 - addrHeaderExtra;
                        currentPage.drawLine({ start: { x: mSide + SECTION_PAD, y: addrUnderlineY }, end: { x: pageWidth - mSide - SECTION_PAD, y: addrUnderlineY }, thickness: 0.5, color: rgb(0.88, 0.88, 0.88) });
                        y -= 30 + addrHeaderExtra;
                        const addrInnerW = contentWidth - (SECTION_PAD * 2);
                        // Type selector checkboxes (optional)
                        if (b.includeTypeSelector) {
                            y -= 4; // Add slight space below header line
                            const addrTypeLabelText = 'Select Address Type:';
                            currentPage.drawText(addrTypeLabelText, { x: mSide + 10, y, size: 9, font: fontBold, color: gray });
                            currentPage.drawText(' *', { x: mSide + 10 + fontBold.widthOfTextAtSize(addrTypeLabelText, 9), y, size: 9, font: fontBold, color: red });
                            let typeX = mSide + 10 + fontBold.widthOfTextAtSize(addrTypeLabelText + ' *', 9) + 15;
                            const typeLabels = ['Local', 'Permanent', 'Billing'];
                            typeLabels.forEach((label, i) => {
                                const typeCb = form.createCheckBox(b.fieldPrefix + '_type_' + label.toLowerCase());
                                typeCb.addToPage(currentPage, { x: typeX, y: y - 3, width: 12, height: 12 });
                                setFieldA11y(typeCb, 'Address Type: ' + label, true);
                                currentPage.drawText(label, { x: typeX + 15, y, size: 9, font, color: gray });
                                typeX += 15 + font.widthOfTextAtSize(label, 9) + 20;
                            });
                            y -= 22;
                        }
                        // Street Address (80%) and Apt (20%) layout
                        const streetW = addrInnerW * 0.80;
                        const aptW = addrInnerW * 0.18;
                        const streetGap = 10;
                        // Street Address with required *
                        currentPage.drawText('Street Address', { x: mSide + 10, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + 10 + fontBold.widthOfTextAtSize('Street Address', 9), y, size: 9, font: fontBold, color: red });
                        // Apt (no required)
                        currentPage.drawText('Apt', { x: mSide + 10 + streetW + streetGap, y, size: 9, font: fontBold, color: gray });
                        y -= LABEL_GAP;
                        const addrStreet = form.createTextField(b.fieldPrefix + '_street');
                        addrStreet.addToPage(currentPage, { x: mSide + 10, y: y - FIELD_HEIGHT, width: streetW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(addrStreet, 'Street Address', true);
                        const addrApt = form.createTextField(b.fieldPrefix + '_apt');
                        addrApt.addToPage(currentPage, { x: mSide + 10 + streetW + streetGap, y: y - FIELD_HEIGHT, width: aptW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(addrApt, 'Apt', false);
                        y -= FIELD_HEIGHT + FIELD_ROW_GAP;
                        // City, State, Country, Zip Code row - all with required *
                        const cityW = addrInnerW * 0.32, stateW = addrInnerW * 0.12, countryW = addrInnerW * 0.24, zipW = addrInnerW * 0.20;
                        const gap2 = 8;
                        currentPage.drawText('City', { x: mSide + 10, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + 10 + fontBold.widthOfTextAtSize('City', 9), y, size: 9, font: fontBold, color: red });
                        currentPage.drawText('State', { x: mSide + 10 + cityW + gap2, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + 10 + cityW + gap2 + fontBold.widthOfTextAtSize('State', 9), y, size: 9, font: fontBold, color: red });
                        currentPage.drawText('Country', { x: mSide + 10 + cityW + stateW + gap2*2, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + 10 + cityW + stateW + gap2*2 + fontBold.widthOfTextAtSize('Country', 9), y, size: 9, font: fontBold, color: red });
                        currentPage.drawText('Zip Code', { x: mSide + 10 + cityW + stateW + countryW + gap2*3, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + 10 + cityW + stateW + countryW + gap2*3 + fontBold.widthOfTextAtSize('Zip Code', 9), y, size: 9, font: fontBold, color: red });
                        y -= LABEL_GAP;
                        const addrCity = form.createTextField(b.fieldPrefix + '_city');
                        addrCity.addToPage(currentPage, { x: mSide + 10, y: y - FIELD_HEIGHT, width: cityW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(addrCity, 'City', true);
                        const addrState = form.createTextField(b.fieldPrefix + '_state');
                        addrState.addToPage(currentPage, { x: mSide + 10 + cityW + gap2, y: y - FIELD_HEIGHT, width: stateW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(addrState, 'State', true);
                        const addrCountry = form.createTextField(b.fieldPrefix + '_country');
                        addrCountry.addToPage(currentPage, { x: mSide + 10 + cityW + stateW + gap2*2, y: y - FIELD_HEIGHT, width: countryW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(addrCountry, 'Country', true);
                        const addrZip = form.createTextField(b.fieldPrefix + '_zip');
                        addrZip.addToPage(currentPage, { x: mSide + 10 + cityW + stateW + countryW + gap2*3, y: y - FIELD_HEIGHT, width: zipW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(addrZip, 'Zip Code', true);
                        y -= FIELD_HEIGHT + FIELD_ROW_GAP;
                        // Phone fields (optional)
                        if (b.includePhone) {
                            // Country Code label
                            const countryCodeLabel = 'Country Code';
                            currentPage.drawText(countryCodeLabel, { x: mSide + 10, y, size: 9, font: fontBold, color: gray });
                            currentPage.drawText(' (non-US)', { x: mSide + 10 + fontBold.widthOfTextAtSize(countryCodeLabel, 9), y, size: 9, font, color: gray });
                            // Area Code label
                            const areaCodeX = mSide + 10 + 80;
                            currentPage.drawText('Area Code', { x: areaCodeX, y, size: 9, font: fontBold, color: gray });
                            currentPage.drawText(' *', { x: areaCodeX + fontBold.widthOfTextAtSize('Area Code', 9), y, size: 9, font: fontBold, color: red });
                            // Phone Number label
                            const phoneNumX = areaCodeX + 80;
                            currentPage.drawText('Phone Number', { x: phoneNumX, y, size: 9, font: fontBold, color: gray });
                            currentPage.drawText(' *', { x: phoneNumX + fontBold.widthOfTextAtSize('Phone Number', 9), y, size: 9, font: fontBold, color: red });
                            y -= LABEL_GAP;
                            // Phone input fields
                            const countryCodeW = 70;
                            const areaCodeW = 70;
                            const phoneNumW = addrInnerW - countryCodeW - areaCodeW - 130;
                            const phoneCC = form.createTextField(b.fieldPrefix + '_country_code');
                            phoneCC.addToPage(currentPage, { x: mSide + 10, y: y - FIELD_HEIGHT, width: countryCodeW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                            setFieldA11y(phoneCC, 'Country Code (non-US)', false);
                            const phoneAC = form.createTextField(b.fieldPrefix + '_area_code');
                            phoneAC.addToPage(currentPage, { x: areaCodeX, y: y - FIELD_HEIGHT, width: areaCodeW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                            setFieldA11y(phoneAC, 'Area Code', true);
                            const phoneNum = form.createTextField(b.fieldPrefix + '_phone');
                            phoneNum.addToPage(currentPage, { x: phoneNumX, y: y - FIELD_HEIGHT, width: phoneNumW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                            setFieldA11y(phoneNum, 'Phone Number', true);
                            // Make primary phone checkbox
                            const phoneCb = form.createCheckBox(b.fieldPrefix + '_primary_phone');
                            phoneCb.addToPage(currentPage, { x: phoneNumX + phoneNumW + 15, y: y - 12, width: 12, height: 12 });
                            setFieldA11y(phoneCb, 'Make primary phone', false);
                            currentPage.drawText('Make primary phone', { x: phoneNumX + phoneNumW + 30, y: y - 10, size: 9, font, color: gray });
                            y -= 26;
                        }
                        y -= BLOCK_GAP;
                        break;

                    case 'student-info':
                        const siTitleLines = wrapText(b.title.toUpperCase(), contentWidth - SECTION_PAD * 2, fontBold, 11);
                        const siHeaderExtra = (siTitleLines.length - 1) * 14;
                        const siH = 96 + siHeaderExtra;
                        ensureSpace(siH + BLOCK_GAP);
                        currentPage.drawRectangle({ x: mSide, y: y - siH, width: contentWidth, height: siH, color: rgb(0.98, 0.98, 0.98), borderColor: rgb(0.89, 0.89, 0.89), borderWidth: 0.5 });
                        siTitleLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 14 - i * 14, size: 11, font: fontBold, color: red });
                        });
                        const siUnderlineY = y - 20 - siHeaderExtra;
                        currentPage.drawLine({ start: { x: mSide + SECTION_PAD, y: siUnderlineY }, end: { x: pageWidth - mSide - SECTION_PAD, y: siUnderlineY }, thickness: 0.5, color: rgb(0.88, 0.88, 0.88) });
                        y -= 30 + siHeaderExtra;
                        // Row 1: Name fields (Last, First, Middle)
                        const siInnerW = contentWidth - (SECTION_PAD * 2);
                        const nameW1 = siInnerW * 0.38, nameW2 = siInnerW * 0.32, nameW3 = siInnerW * 0.26;
                        const nameGap = ROW_GAP;
                        // Last Name with required *
                        currentPage.drawText('Last Name', { x: mSide + SECTION_PAD, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + fontBold.widthOfTextAtSize('Last Name', 9), y, size: 9, font: fontBold, color: red });
                        // First Name with required *
                        currentPage.drawText('First Name', { x: mSide + SECTION_PAD + nameW1 + nameGap, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + nameW1 + nameGap + fontBold.widthOfTextAtSize('First Name', 9), y, size: 9, font: fontBold, color: red });
                        // Middle Name (no required)
                        currentPage.drawText('Middle Name', { x: mSide + SECTION_PAD + nameW1 + nameW2 + nameGap*2, y, size: 9, font: fontBold, color: gray });
                        y -= LABEL_GAP;
                        const siLast = form.createTextField(b.fieldPrefix + '_last');
                        siLast.addToPage(currentPage, { x: mSide + SECTION_PAD, y: y - FIELD_HEIGHT, width: nameW1, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(siLast, 'Last Name', true);
                        const siFirst = form.createTextField(b.fieldPrefix + '_first');
                        siFirst.addToPage(currentPage, { x: mSide + SECTION_PAD + nameW1 + nameGap, y: y - FIELD_HEIGHT, width: nameW2, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(siFirst, 'First Name', true);
                        const siMiddle = form.createTextField(b.fieldPrefix + '_middle');
                        siMiddle.addToPage(currentPage, { x: mSide + SECTION_PAD + nameW1 + nameW2 + nameGap*2, y: y - FIELD_HEIGHT, width: nameW3 - nameGap, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(siMiddle, 'Middle Name', false);
                        y -= FIELD_HEIGHT + FIELD_ROW_GAP;
                        // Row 2: UGA ID (left) + Email (right)
                        const siHalfW = (siInnerW - 12) / 2;
                        // UGA ID Number with required * and inline hint
                        const ugaIdLabel = 'UGA ID (810X) Number';
                        currentPage.drawText(ugaIdLabel, { x: mSide + SECTION_PAD, y, size: 9, font: fontBold, color: gray });
                        const ugaIdLabelW = fontBold.widthOfTextAtSize(ugaIdLabel, 9);
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + ugaIdLabelW, y, size: 9, font: fontBold, color: red });
                        // Contact Email Address with required *
                        currentPage.drawText('Contact Email Address', { x: mSide + SECTION_PAD + siHalfW + 12, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + siHalfW + 12 + fontBold.widthOfTextAtSize('Contact Email Address', 9), y, size: 9, font: fontBold, color: red });
                        y -= LABEL_GAP;
                        // UGA ID field
                        const siUgaId = form.createTextField(b.fieldPrefix + '_ugaid');
                        siUgaId.addToPage(currentPage, { x: mSide + SECTION_PAD, y: y - FIELD_HEIGHT, width: siHalfW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(siUgaId, 'UGA ID (810X) Number', true);
                        // Email field on right
                        const siEmail = form.createTextField(b.fieldPrefix + '_email');
                        siEmail.addToPage(currentPage, { x: mSide + SECTION_PAD + siHalfW + 12, y: y - FIELD_HEIGHT, width: siHalfW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(siEmail, 'Contact Email Address', true);
                        y -= FIELD_HEIGHT + SECTION_PAD + BLOCK_GAP;
                        break;

                    case 'course-info':
                        const ciTitleLines = wrapText(b.title.toUpperCase(), contentWidth - SECTION_PAD * 2, fontBold, 11);
                        const ciHeaderExtra = (ciTitleLines.length - 1) * 14;
                        const ciH = 62 + ciHeaderExtra;
                        ensureSpace(ciH + BLOCK_GAP);
                        currentPage.drawRectangle({ x: mSide, y: y - ciH, width: contentWidth, height: ciH, color: rgb(0.98, 0.98, 0.98), borderColor: rgb(0.89, 0.89, 0.89), borderWidth: 0.5 });
                        ciTitleLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide + SECTION_PAD, y: y - 14 - i * 14, size: 11, font: fontBold, color: red });
                        });
                        const ciUnderlineY = y - 20 - ciHeaderExtra;
                        currentPage.drawLine({ start: { x: mSide + SECTION_PAD, y: ciUnderlineY }, end: { x: pageWidth - mSide - SECTION_PAD, y: ciUnderlineY }, thickness: 0.5, color: rgb(0.88, 0.88, 0.88) });
                        y -= 30 + ciHeaderExtra;
                        const ciInnerW = contentWidth - (SECTION_PAD * 2);
                        const ciFieldW = (ciInnerW - (GRID_GAP * 3)) / 4;
                        const ciGap = GRID_GAP;
                        currentPage.drawText('CRN', { x: mSide + SECTION_PAD, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + fontBold.widthOfTextAtSize('CRN', 9), y, size: 9, font: fontBold, color: red });
                        currentPage.drawText('Course Prefix', { x: mSide + SECTION_PAD + ciFieldW + ciGap, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + ciFieldW + ciGap + fontBold.widthOfTextAtSize('Course Prefix', 9), y, size: 9, font: fontBold, color: red });
                        currentPage.drawText('Course Number', { x: mSide + SECTION_PAD + (ciFieldW + ciGap) * 2, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + (ciFieldW + ciGap) * 2 + fontBold.widthOfTextAtSize('Course Number', 9), y, size: 9, font: fontBold, color: red });
                        currentPage.drawText('Credit Hours', { x: mSide + SECTION_PAD + (ciFieldW + ciGap) * 3, y, size: 9, font: fontBold, color: gray });
                        currentPage.drawText(' *', { x: mSide + SECTION_PAD + (ciFieldW + ciGap) * 3 + fontBold.widthOfTextAtSize('Credit Hours', 9), y, size: 9, font: fontBold, color: red });
                        y -= LABEL_GAP;
                        const ciCrn = form.createTextField(b.fieldPrefix + '_crn');
                        ciCrn.addToPage(currentPage, { x: mSide + SECTION_PAD, y: y - FIELD_HEIGHT, width: ciFieldW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(ciCrn, 'CRN', true);
                        const ciPrefix = form.createTextField(b.fieldPrefix + '_prefix');
                        ciPrefix.addToPage(currentPage, { x: mSide + SECTION_PAD + ciFieldW + ciGap, y: y - FIELD_HEIGHT, width: ciFieldW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(ciPrefix, 'Course Prefix', true);
                        const ciNumber = form.createTextField(b.fieldPrefix + '_number');
                        ciNumber.addToPage(currentPage, { x: mSide + SECTION_PAD + (ciFieldW + ciGap) * 2, y: y - FIELD_HEIGHT, width: ciFieldW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(ciNumber, 'Course Number', true);
                        const ciHours = form.createTextField(b.fieldPrefix + '_hours');
                        ciHours.addToPage(currentPage, { x: mSide + SECTION_PAD + (ciFieldW + ciGap) * 3, y: y - FIELD_HEIGHT, width: ciFieldW, height: FIELD_HEIGHT, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                        setFieldA11y(ciHours, 'Credit Hours', true);
                        y -= FIELD_HEIGHT + SECTION_PAD + BLOCK_GAP;
                        break;

                    case 'info-paragraph':
                        const infoText = b.text || '';
                        const infoLineHeight = 14;
                        const infoTitleLineHeight = 14;
                        const infoMaxWidth = contentWidth - 20;
                        const infoSourceLines = infoText.split('\n');

                        // Bold-aware line wrapping: parses **bold** markers first,
                        // then word-wraps with correct font per word.
                        // Returns array of lines, each line is array of {text, bold} tokens.
                        function wrapInfoBoldLine(lineContent, maxWidth, indent) {
                            const availW = maxWidth - indent;
                            const rawParts = lineContent.split(/(\*\*[^*]+\*\*)/g);
                            const segments = rawParts.filter(p => p !== '').map(part => {
                                if (part.startsWith('**') && part.endsWith('**')) {
                                    return { text: part.slice(2, -2), bold: true };
                                }
                                return { text: part, bold: false };
                            });
                            const tokens = [];
                            segments.forEach(seg => {
                                seg.text.split(/( +)/).forEach(piece => {
                                    if (piece) tokens.push({ text: piece, bold: seg.bold });
                                });
                            });
                            const lines = [[]];
                            let lineWidth = 0;
                            for (let i = 0; i < tokens.length; i++) {
                                const token = tokens[i];
                                const isSpace = token.text.trim() === '';
                                const f = token.bold ? fontBold : font;
                                const w = f.widthOfTextAtSize(token.text, 9);
                                if (isSpace) {
                                    lines[lines.length - 1].push(token);
                                    lineWidth += w;
                                } else {
                                    if (lineWidth > 0 && lineWidth + w > availW) {
                                        const cur = lines[lines.length - 1];
                                        while (cur.length && cur[cur.length - 1].text.trim() === '') cur.pop();
                                        lines.push([]);
                                        lineWidth = 0;
                                    }
                                    lines[lines.length - 1].push(token);
                                    lineWidth += w;
                                }
                            }
                            const last = lines[lines.length - 1];
                            while (last.length && last[last.length - 1].text.trim() === '') last.pop();
                            return lines.length ? lines : [[]];
                        }

                        // Helper to wrap title text and return array of lines
                        function wrapInfoTitle(title, maxWidth) {
                            const words = title.split(' ');
                            let lines = [];
                            let current = '';
                            words.forEach(word => {
                                const test = current ? current + ' ' + word : word;
                                if (fontBold.widthOfTextAtSize(test, 10) > maxWidth && current) {
                                    lines.push(current);
                                    current = word;
                                } else {
                                    current = test;
                                }
                            });
                            if (current) lines.push(current);
                            return lines.length ? lines : [''];
                        }

                        // Wrap the title
                        const infoTitleLines = wrapInfoTitle(b.title.toUpperCase(), infoMaxWidth);
                        const infoTitleHeight = infoTitleLines.length * infoTitleLineHeight;

                        // Pre-compute all wrapped body lines (bold-aware) for height AND rendering
                        const allInfoLines = [];
                        infoSourceLines.forEach(line => {
                            const isBullet = line.trim().startsWith('- ');
                            const cleanLine = isBullet ? line.trim().substring(2) : line;
                            const indent = isBullet ? 12 : 0;
                            const wrapped = wrapInfoBoldLine(cleanLine, infoMaxWidth, indent);
                            wrapped.forEach((tokens, i) => {
                                allInfoLines.push({ tokens, isBullet, isFirstOfBullet: isBullet && i === 0 });
                            });
                        });

                        const infoBoxH = 20 + infoTitleHeight + 10 + (allInfoLines.length * infoLineHeight);
                        ensureSpace(infoBoxH + 20);

                        // Single light background box
                        currentPage.drawRectangle({ x: mSide, y: y - infoBoxH, width: contentWidth, height: infoBoxH, color: rgb(0.96, 0.94, 0.92) });

                        // Header text (dark, uppercase) with wrapping
                        let infoTitleY = y - 14;
                        infoTitleLines.forEach(titleLine => {
                            currentPage.drawText(titleLine, { x: mSide + 10, y: infoTitleY, size: 10, font: fontBold, color: gray });
                            infoTitleY -= infoTitleLineHeight;
                        });

                        // Underline after title
                        const underlineY = y - 14 - infoTitleHeight - 4;
                        currentPage.drawLine({ start: { x: mSide + 10, y: underlineY }, end: { x: pageWidth - mSide - 10, y: underlineY }, thickness: 0.5, color: rgb(0.75, 0.75, 0.75) });

                        // Render all pre-computed wrapped body lines
                        let infoY = underlineY - 14;
                        allInfoLines.forEach(wl => {
                            const baseX = mSide + 10;
                            const indent = wl.isBullet ? 12 : 0;
                            let infoX = baseX + indent;
                            if (wl.isFirstOfBullet) {
                                currentPage.drawText('', { x: baseX, y: infoY, size: 9, font, color: gray });
                            }
                            wl.tokens.forEach(token => {
                                if (token.text.trim() === '') {
                                    infoX += font.widthOfTextAtSize(token.text, 9);
                                } else {
                                    const f = token.bold ? fontBold : font;
                                    currentPage.drawText(token.text, { x: infoX, y: infoY, size: 9, font: f, color: gray });
                                    infoX += f.widthOfTextAtSize(token.text, 9);
                                }
                            });
                            infoY -= infoLineHeight;
                        });
                        y -= infoBoxH + BLOCK_GAP;
                        break;

                    case 'signature':
                        // Default required to true for backwards compat with saved templates
                        const sigIsRequired = b.required !== undefined ? b.required : true;
                        // Fixed-width label column for consistent alignment across signature blocks
                        const SIG_LABEL_W = 150;
                        const sigLineStartX = mSide + SIG_LABEL_W + 10;

                        // Photo ID box dimensions (right side)
                        const photoIdBoxW = 140;
                        const photoIdBoxH = 40;
                        const photoIdBoxX = pageWidth - mSide - photoIdBoxW;
                        const sigLineEndX = b.includePhotoId ? (photoIdBoxX - 15) : (pageWidth - mSide);
                        const sigLineW = sigLineEndX - sigLineStartX;

                        // Wrap label text within fixed-width column
                        const sigLabelLines = wrapText(b.label, SIG_LABEL_W, fontBold, 10);
                        const sigLabelH = sigLabelLines.length * 14;
                        const sigRowH = Math.max(sigLabelH, 18);
                        const dateRowH = b.includeDate ? 22 : 0;
                        const sigTotalH = sigRowH + dateRowH + BLOCK_GAP;

                        ensureSpace(Math.max(sigTotalH, b.includePhotoId ? photoIdBoxH + BLOCK_GAP : 0) + BLOCK_GAP);
                        y -= BLOCK_GAP;

                        // Draw wrapped label lines
                        const sigLabelStartY = y;
                        sigLabelLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide, y: sigLabelStartY - i * 14, size: 10, font: fontBold, color: gray });
                            if (sigIsRequired && i === sigLabelLines.length - 1) {
                                currentPage.drawText(' *', { x: mSide + fontBold.widthOfTextAtSize(line, 10), y: sigLabelStartY - i * 14, size: 10, font: fontBold, color: red });
                            }
                        });

                        // Signature line (aligned to first label line)
                        currentPage.drawLine({ start: { x: sigLineStartX, y: y - 2 }, end: { x: sigLineEndX, y: y - 2 }, thickness: 0.5, color: rgb(0.5, 0.5, 0.5) });
                        y -= sigRowH;

                        // Date row
                        if (b.includeDate) {
                            currentPage.drawText('Date', { x: mSide, y: y + 4, size: 10, font: fontBold, color: gray });
                            if (sigIsRequired) {
                                currentPage.drawText(' *', { x: mSide + fontBold.widthOfTextAtSize('Date', 10), y: y + 4, size: 10, font: fontBold, color: red });
                            }
                            const dateField = form.createTextField(b.fieldName + '_date');
                            dateField.addToPage(currentPage, { x: sigLineStartX, y: y - 10, width: sigLineW, height: 18, borderWidth: 1, borderColor: rgb(0.81, 0.81, 0.81) });
                            setFieldA11y(dateField, 'Date', sigIsRequired);
                            y -= dateRowH;
                        }

                        // Photo ID attachment box (right-aligned)
                        if (b.includePhotoId) {
                            const photoIdBoxY = sigLabelStartY - photoIdBoxH + 5;
                            currentPage.drawRectangle({
                                x: photoIdBoxX, y: photoIdBoxY,
                                width: photoIdBoxW, height: photoIdBoxH,
                                borderColor: rgb(0.6, 0.6, 0.6),
                                borderWidth: 1,
                                color: rgb(0.98, 0.98, 0.98),
                                borderDashArray: [4, 3]
                            });
                            const iconX = photoIdBoxX + 22;
                            const iconY = photoIdBoxY + photoIdBoxH/2;
                            currentPage.drawRectangle({ x: iconX - 12, y: iconY - 8, width: 24, height: 16, borderColor: rgb(0.4, 0.4, 0.4), borderWidth: 1 });
                            currentPage.drawEllipse({ x: iconX - 5, y: iconY - 1, xScale: 3, yScale: 3, borderColor: rgb(0.4, 0.4, 0.4), borderWidth: 0.75 });
                            currentPage.drawLine({ start: { x: iconX + 1, y: iconY + 1 }, end: { x: iconX + 8, y: iconY + 1 }, thickness: 1, color: rgb(0.4, 0.4, 0.4) });
                            currentPage.drawLine({ start: { x: iconX + 1, y: iconY - 3 }, end: { x: iconX + 8, y: iconY - 3 }, thickness: 1, color: rgb(0.4, 0.4, 0.4) });
                            currentPage.drawText('Include copy of', { x: photoIdBoxX + 45, y: photoIdBoxY + 24, size: 9, font: fontBold, color: gray });
                            currentPage.drawText('Photo ID', { x: photoIdBoxX + 45, y: photoIdBoxY + 12, size: 9, font: fontBold, color: gray });
                            if (sigIsRequired) {
                                currentPage.drawText(' *', { x: photoIdBoxX + 45 + fontBold.widthOfTextAtSize('Photo ID', 9), y: photoIdBoxY + 12, size: 9, font: fontBold, color: red });
                            }
                        }
                        break;

                    case 'office-use':
                        const ouTitleLines = wrapText(b.title.toUpperCase(), contentWidth - 16, fontBold, 9);
                        const ouTitleExtra = (ouTitleLines.length - 1) * 12;
                        const approvalH = b.includeApprovalCheckboxes ? 20 : 0;
                        const linesH = Math.ceil(b.lines.length / 2) * 22;
                        const boxH = linesH + approvalH + 24 + ouTitleExtra;
                        ensureSpace(boxH + 6);
                        currentPage.drawRectangle({ x: mSide, y: y - boxH, width: contentWidth, height: boxH, borderWidth: 0.75, borderColor: rgb(0, 0, 0) });
                        ouTitleLines.forEach((line, i) => {
                            currentPage.drawText(line, { x: mSide + 8, y: y - 12 - i * 12, size: 9, font: fontBold, color: gray });
                        });
                        y -= 20 + ouTitleExtra;

                        // Approval checkboxes + denial reason all on one line
                        if (b.includeApprovalCheckboxes) {
                            const approvedCb = form.createCheckBox('office_approved');
                            approvedCb.addToPage(currentPage, { x: mSide + 8, y: y - 8, width: 10, height: 10 });
                            setFieldA11y(approvedCb, 'Request Approved', false);
                            currentPage.drawText('Request Approved', { x: mSide + 22, y: y - 6, size: 9, font, color: gray });

                            const deniedCb = form.createCheckBox('office_denied');
                            deniedCb.addToPage(currentPage, { x: mSide + 115, y: y - 8, width: 10, height: 10 });
                            setFieldA11y(deniedCb, 'Request Denied', false);
                            currentPage.drawText('Request Denied', { x: mSide + 129, y: y - 6, size: 9, font, color: gray });

                            currentPage.drawText('Denial Reason:', { x: mSide + 215, y: y - 6, size: 9, font, color: gray });
                            const denialField = form.createTextField('office_denial_reason');
                            denialField.addToPage(currentPage, { x: mSide + 285, y: y - 10, width: contentWidth - 295, height: 14, borderWidth: 1, borderColor: rgb(0.7, 0.7, 0.7) });
                            setFieldA11y(denialField, 'Denial Reason', false);
                            y -= 18;
                        }

                        // Lines in 50/50 split layout with text fields
                        const halfW = (contentWidth - 28) / 2;
                        for (let i = 0; i < b.lines.length; i += 2) {
                            // Left side
                            const leftLine = b.lines[i];
                            const leftLabelW = font.widthOfTextAtSize(leftLine + ':', 9) + 4;
                            currentPage.drawText(leftLine + ':', { x: mSide + 8, y: y - 4, size: 9, font: font, color: gray });
                            const leftField = form.createTextField('office_' + leftLine.toLowerCase().replace(/\s+/g, '_'));
                            leftField.addToPage(currentPage, { x: mSide + 8 + leftLabelW, y: y - 8, width: halfW - leftLabelW - 4, height: 14, borderWidth: 1, borderColor: rgb(0.7, 0.7, 0.7) });
                            setFieldA11y(leftField, leftLine, false);

                            // Right side (if exists)
                            if (i + 1 < b.lines.length) {
                                const rightLine = b.lines[i + 1];
                                const rightLabelW = font.widthOfTextAtSize(rightLine + ':', 9) + 4;
                                currentPage.drawText(rightLine + ':', { x: mSide + 8 + halfW + 12, y: y - 4, size: 9, font: font, color: gray });
                                const rightField = form.createTextField('office_' + rightLine.toLowerCase().replace(/\s+/g, '_'));
                                rightField.addToPage(currentPage, { x: mSide + 8 + halfW + 12 + rightLabelW, y: y - 8, width: halfW - rightLabelW, height: 14, borderWidth: 1, borderColor: rgb(0.7, 0.7, 0.7) });
                                setFieldA11y(rightField, rightLine, false);
                            }
                            y -= 20;
                        }
                        y -= BLOCK_GAP;
                        break;

                    case 'footer':
                        ensureSpace(30);
                        y -= BLOCK_GAP;
                        currentPage.drawLine({ start: { x: mSide, y: y }, end: { x: pageWidth - mSide, y: y }, thickness: 0.5, color: rgb(0.8, 0.8, 0.8) });
                        y -= 12;
                        const footerText = `Revised ${b.revisedMonth} ${b.revisedYear}`;
                        const footerWidth = font.widthOfTextAtSize(footerText, 9);
                        currentPage.drawText(footerText, { x: (pageWidth - footerWidth) / 2, y, size: 9, font: font, color: rgb(0.4, 0.4, 0.4) });
                        y -= BLOCK_GAP;
                        break;
                }
            }

            const bytes = await pdf.save();
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = document.getElementById('formTitle').value.replace(/[^a-z0-9]/gi, '_') + '.pdf';
            a.click();
        }

        render();
    </script>
</body>
</html>
